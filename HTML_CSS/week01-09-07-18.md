# 09-07-18

---

**WAI - ARIA**
- 국제 웹접근성 표준 : 접근성을 고려하지 않은(HTML5 이전) div를 남발한 마크업들이 많다.
- 예를 들어, role="<콘텐츠>" 이런 식으로 부여해주면 이미 작성된 코드에 접근성 관련하여 좀 더 나은 환경을 제공할 수 있다.
- div로 버튼 처리를 한 마크업은 키보드로 선택할 수도 없고 기계가 읽어줄 수도 없는데, 여기에도 role="button" 처리를 한 뒤에 스크립트로 키보드 선택을 할 수 있도록 만들면 된다.

---

CSS에서 가장 어려운 것은 layout이다.

- box model, grid, flex도 있지만 현업에서는 float과 position도 알아야한다.

---

### 수업 실습 : 박스모델 관련


- box-sizing 관련 레퍼런스 찾아보기

*마진의 특성*
> 마진은 투명하다. 실제 크기가 커졌지만 보이지 않기 때문에 이동했다고 착각함. 그래서 오토 값을 주면 뷰포트 값을 기준으로 남는 여백의 수치를 절반으로 나누어 좌우에 값을 준다. 그렇기 때문에 가운데 정렬은 아니지만 가운데에 위치하게 된다.

```css
.main{
 
  background-color: blue;
  /* 10vh = 10%  */
  /* height: 60vh;  */

  /* 이 메인 요소는 플렉스 박스에서 플렉스 컨테이너가 된다 */
  display: flex;
  /* row설정이기 때문에 x축 방향으로  */
  flex-direction: row;
  /* justify-content : 메인축 정렬, center 사용으로 가운데 위치시킬 수 있다. space-between : 사이 사이에 간격을 준다. space-around : gutter 크기의 절반만큼을 좌 우에 배치시킨다. space-evenly : 균등하게 여백이 배분되는 설정  */
   justify-content: space-evenly;

  padding: 30px 0; 
  ```

---

### 수업 실습 : 플렉스 박스

- 플렉스 선언하고 싶으면 부모를 플렉스 컨테이너로!
- 그 직계 자손들은 플렉스 아이템들이 된다(아이템의 자손들은 플렉스 적용 안됨)
- justify-content: 메인축 정렬
- align-content: 여러 개 item간의 정렬
- align-items: 교차축 정렬(컨테이너에 주는 설정)
- align-self: 교차축 정렬. 아이템에 주는 설정
- flex-basis: width 크기 설정


숫자 값만 올 수 있는
- flex-grow
- flex-shrink


---

### Float

- float 적용 시, normal flow(위에서 아래로)를 벗어나게 해서 배치시키게 한다
- 부모 영역의 라인박스 안에서 맨 왼쪽으로 float 된다고 생각하면 된다

- 텍스트 노드는 겹치지 않는다

- 이미 float가 적용된 라인 박스부터 적용된다(이미 오른쪽에 플로트 된 박스가 있다면 그 박스 옆이 라인박스의 시작이 되는 것이다)

- 플로트 처리가 안된 박스에 플로트 처리된 박스가 끼어들었을 때, 만약 처리가 안된 박스의 위드 값이 더 작다면 글자가 밀려 아래로 내려갈 수 있다(수업 실습을 생각하자)

- 플로트 배치로 인해 죽은 공간이 생길 수 있다 - 그렇기 때문에 플로트가 어떻게 작동하는지 이해하는 것이 매우 중요함

- 부모의 높이가 설정되지 않으면 자식들의 높이 총 합이 총 높이가 된다



**clear** 
  - block속성에 적용이 되는 요소
    - `<span>`에는 적용되지 않는다 - 이와 같이 적용되지 않는 요소들이 있다. 혹은 디스플레이 속성을 block으로 바꾸면 된다.
  - 플로트를 해제 시킨다 : 플로트되서 떠있는 아이템들과 겹치지 않는다. 
  - 클리어 기능은 플로트가 해제되는 만큼의 추가 마진이 생긴다 - 강제로 마진을 추가시킨다고 보면 된다.
    - 이를 해결하기 위해서는 형제레벨(비어있는 블락)을 생성해서 클리어픽스(clearfix)를 만들어 준다.
     - 그래서 가상 클래스를 만든다 - .main::after를 사용, content: <이름>이 동반되어야 함. 이름을 ""로 비워놓으면 화면에서 사라지게 할 수 있다(내용이 비어있으면 height: 0 취급).
     - before, after : first child 취급, last child 취급. inline box 취급되기 때문에 clear를 바로 줄 수 없다
  - 이런 모듈을 하나 만들어서 필요한 클래스에 적용시켜서 사용하면 된다

      ```css
        .clearfix::after{
          content: "";
          display: block;
          clear: both;
        }
     ```

  - `overflow: hidden;`를 적용(또 다른 블록을 생성)해서 잃어버린 높이를 적용시킬 수 있다.
  
  - 이 방법들 중에서 가상요소 활용한 해결이 가장 안정적일 수 있다.

  - [참조하기 좋은 레퍼런스](http://naradesign.net/wp/2008/05/27/144/)
 
  - 이중 플로트 
    - 박스 1, 2, 3이 있을 때 박스 1을 가운데 위치시키고 싶다?
      - 박스 1, 2를 컨테이너 1로 묶은 뒤 컨테이터 1과 박스 3이 있을 때 컨테이너 1을 왼쪽 플로트
        - 그 후, 그 안에서 박스 1, 2를 플로트 적용해서 놓아 준다.

  
  ```
  기준이 column일 때는 높이가 오토, row일 때는 width가 오토

  shift alt down : 행 복사 후 추가
  ```


  ---

  style.css 파일 예제 수업

  ### 마크업

  - 콘텐츠 중심의 마크업이 필요
    - 논리적인 마크업

  - 옛날에는 레이아웃을 위해서 테이블을 사용하여 레이아웃을 구성
    - 이는 논리성을 지키기 어려우므루 최대한 지양해야하는 방법

  

  ---

  웹카페 예제 구성 파악하기

  - 헤더 영역
    - 로고
    - 텍스트 링크 모음
    - 메뉴

  어떤 순서로 마크업을 시작해야? 

  1. 로고를 가장 먼저 -> 페이지를 대표하는 로고
  2. 사용자가 어떠한 경로를 먼저 거쳐야하는 지를 고민해보고 순서를 정해야 한다

  이제 여기에 시맨틱 마크업을
  1. 로고가 가장 중요한 의미를 나타낼 것이기에 `<h1>`태그를 지정해 주자
  2. 텍스트 링크르는 `<a>`가 필요할 것이고 홈이던 로그인이던 무엇이 먼저 나와도 되지 않기에 `<ul>`요소를 사용할 것이다.
    - ul tag는 자식요소로 무조건 `<li>`요소를 사용해야 한다
  3. 메뉴영역은 웹사이트의 주요 네비게이션 - `<nav>`요소를 사용한다. 역시 여기에서도 `<ul>`요소를 사용할 수 있겠다.
  4. 네이밍을 한다 - 최대한 의미있는 네이밍이 동반되어야 한다.

  구조도를 그려보자

  ```
  header.header
    h1.logo image - img태그를 사용할 것 -> 이 위에 하이퍼링크로 감싸주어서 인덱스화면으로 갈 수 있도록 설정해 줄 것
        - 이미지 태그를 사용할 때 alt=""(대체텍스트)를 꼭 지정해주자

    ul.info
     앵커 안에 - li 홈
     앵커 안에 - li 로그인


    nav.navigation 
    - nav 태그는 최대한 주요 네비게이션에만 쓰도록 한다 

      h2 - h1요소의 영향을 받기 때문에 - 메인메뉴라 이름을 주고 a11y-hidden 사용(보이지 않더라도 의미적인 구조가 필요하면 구조에 포함해야 한다)
          
      구성할 시에 텍스트 먼저 입력하고 
      ul.info>li*>a[href="#"]
      입력해주면 매우 편하게 구조할 수 있다

        * 글자색 줄 때 상속문제가 발생할 수 있다 : 그래서 특정한 텍스트를 span으로 묶어 그곳에만 클래스 설정 후 색을 적용시킬 수 있다
        * 상속자 지정을 신중히 해주어야 한다. 그러기 위해서는 클래스명을 지정해줄 수 있다.
        * 직계 자식 지정을 해주어도 되긴 하지만 그것은 직속 자식요소만 적용시킬 수 밖에 없을 수 있기 때문에, <클래스 명>을 정해줘서 스타일링을 하는 것이 매우 편리하다.

        ul - 메인메뉴 (html에 대해... etc)
        - 이미지를 사용하지 않고 CSS로 작성 시 장점 : 해상도가 깨지지 않고 유지보수가 편하고 용량이 작다.
            li . . . 
              이 밑의 또 다른 메뉴들 때문에
                ul
                  li
      
      


```

[예](http://www.csszengarden.com/213/)
- 이런 경우에는 image replace 기법을 사용해서 image를 css에서 적용할 수 있다.

[나쁜 예](http://responsivelogos.co.uk/)
- 반응형 로고: 이는 텍스트노드가 코카콜라 로고에 없기 때문에 접근성면에서는 매우 나쁜 예.
  - 텍스트를 썼을 때 image replace를 할 수 없다면, aira-label="코카콜라" 이런 식으로 접근성면을 보완시킬 수 있다!

HTML에서는 `<a>`, `<area>`, `<button>`,`<input>`, `<select>`, `<textarea>` 등 만이 키보드 포커스를 받는데, `tabindex="0"`(0을 주는 이유는 마크업된 순서로 접근하라고 지정해주기 위해) 설정을 해주면 따로 키보드 포커스를 받게 설정해줄 수 있다(jQuery 사용해서). 


---

### 포지션 속성

position: relative
- position: relative는 상대적 배치 개념. **자신이 본래 있었던 자리를 기준으로 움직**이게 된다. normal flow는 유지한다.

position: absolute
- position: absolute(fixed 또한)는 normal flow에 포함되지 않은 것으로 간주된다. 영역을 차지하지 않으며, 상자의 규모를 알려주지 않으면 텍스트 크기에 맞춰져 박스 크기가 정해진다(width, height 둘 다 오토 값).
  - **자신보다 상위 요소이면서 position: static이 아닐 때**를 기준으로 움직이게 된다(자신의 상위요소가 position: static이면 그것을 무시하고 그 상위요소의 포지션 값을 찾는다). 
  - 그렇기 때문에 position: absolute가 하위 요소일 때는 상위 요소가 relative로 설정(기준이 되기 위해) 되어야 한다.
  - absolute 상위에는 absolute가 올 수도 있다.

- position: relative 와 absolute가 겹칠 때는 마지막에 설정된 것이 위로 올라온다. z-index를 사용해 위로 올려올 수 있다.

- 부모의 하이트가 늘어냐야 자식의 하이트 값도 늘어난다.

- position: fixed : vh 기준으로 지정된다.

---

### 스타일 겹침 : 속성들의 점수(파워) - 구체성 점수

```
       요소 선택자 < 클래스 선택자 < ID 선택자 < 인라인 스타일
       0,0,0,1    0,0,1,0      0,1,0,0   1,0,0,0

      [NOTE]
        *, >, +, ~ 등 콤비네이터(Combinators),
        :not() 가상 클래스는 특성에 영향을 주지 않는다.

      - element selector: 1
      - class selector: 10
      - id selector : 100
      - inline selector : 1000
```

점수가 같을 시에는 가장 최근에 선언된 것이 적용된다.


--- 

오늘의 느낀 점

- 수업 속도가 빨라지면서 더욱 복습과 예습이 필요하다는 것을 느낀다.
- 너무 조바심 내지 않으려고 한다.