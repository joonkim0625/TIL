# 09-20-18

---

오전 자습 시간

---

## JavaScript : 값 참조와 복사

  메모리는 여러 block들이 사물함이 놓여있든 배치되어 있다고 생각하면 된다. 만약에 변수에 값을 선언하면, 이 값은 메모리 block들 중 하나에 저장되게 된다. 이 block들은 저마다 번호(메모리의 주소 값)가 부여되어 있는데 컴퓨터 시스템이 알아서 그 선언된 변수 값이 어디에 저장될 지를 정하게 된다. 

### pass by value

  pass by value는 원래의 값이 선언되어 있으면 시스템이 그 값을 복사해서 사용하는 의미로 볼 수 있다. 위의 설명을 토대로 본다면, 원래의 선언된 값은 처음 저장된 block에 계속 저장되어 있으면서 그 값이 다른 메모리 block으로 복사되는 것이다. 그렇기 때문에 복사해서 사용하는 값에 변화가 온다고 해도 그 본래의 값은 그대로 보존되어 있는다. 만약 원래의 값에 변화를 주고 싶다면 함수를 정의한 후에 `원래의 값 = 함수`로 지정해줄 수 있다.

  불변의 데이터 경우, 그 값이 복사된다.
  - null, undefined, number, string, boolean

### pass by reference

  이 경우는 메모리가 처음에 저장된 block 자체가 함수로 옮겨지면서, 변화가 생기면 그 결과가 바로 원래 저장되어있던 값에 변화를 주는 것으로 볼 수 있다. 이는 함수가 정의될 때 pass by value 처럼 복사된 메모리 block을 가리키는 것이 아닌 본래의 함수가 지정된 값을 가리키는 것이다. pass by reference의 성질을 이용하면 여러 개의 변수들을 한번에 변경할 수 있다.

  가변(mutable)  데이터의 경우 값이 참조되는데, 객체 유형(객체, 배열, 함수)등이 이에 속한다
  - object, array, function

  ---

## 함수 영역(function scope) vs 블록 영역(block scope)

### global scope 
  
  가장 간단한 변수 영역으로 소스 코드 상의 모든 곳에서 사용할 수 있는 변수가 `전역`변수 이다. 전역 변수는 많은 언어에서 나쁜 관습으로 취급되지만, 그런 경우에도 함수명이나 클래스 명은 대부분 전역에서 접근할 수 있다. 이름공간을 사용하면 전역 영역에서 변수나 함수명이 충돌하는 것을 막을 수 있다.
  - 자바스크립트는 이름공간(name space)이 없지만 비슷하게 흉내낼 수 있다
    ```js
    var a1 = {};
    ```
    이와 같이 객체를 생성해 준 뒤 `a1.phone = 'Note 8';` 이런 식으로 선언해주게 되면 전역에서 함수명이 충돌하는 것을 방지할 수 있다.

### function scope
  
  대부분의 프로그래밍 언어는 함수 내에서만 유효한 지역 변수를 제공한다. 함수 영역을 사용하는 지역 변수는 함수가 반환되면 더 이상 사용할 수 없다. 
  - 만약 함수 내에 선언되지 않은 변수는 지역 변수로 처리되지 않지만, 이를 전역 변수로 생성한 뒤 처리하기 때문에 안좋은 상황이 발생할 수 있다.

### block scope 
  
  알골과 그의 자손인 C, 그리고 그에 영향을 받은 많은 현대 언어들은 블록 단위 지역변수를 지원한다. 블록 문 내부에 선언된 변수는 블록 영역에서만 접근이 가능하다. JS는 ES6 전 까지는 var 키워드가 블록 영역을 지원하지 않았지만, 그 이후부터 let 키워드로 변수를 선언할 수 있게되면서 블록 영역을 지원하게 되었다.

---

## 변수, 함수 호이스팅(hoisting)/ 스코프 체이닝(scope chaining)

### 호이스팅
  hoisting이란 단어는 사람들이 자바스크립트에서 어떻게 값들이 지정되고 실행되는지에 대한 개념을 일반적으로 생각해낼 때 쓰는 포현이다. 하지만 정확하게는 변수와 함수들이 선언되고 컴파일될 때 메모리에 저장된 후 코드에서 선언된 곳에 그대로 존재하게 된다.
  하지만 호이스팅이라는 개념으로 본다면, 함수가 지정되기 전에 함수를 불러온다 하더라도 여전히 그 함수는 작동하게 된다. 이런 현상이 사람들이 말하는 hoisting 현상으로 자바스크립트에서 context execution이 작동하는 방식이다. 
  - 자바스크립트는 선언된 변수들만 호이스팅 하고 초기화 되는 값들은 하지 않는다. 
   
  자바스크립트에서는 코드를 실행시키기 전에 변수의 선언과 함수의 선언을 메모리에 등록시키는(호이스팅) 과정을 먼저 거친다.
  - 변수는 1.변수를 선언하는 과정 2.값을 할당하는 초기화 과정 3.변수의 영역을 설정하는 과정을 거친다

  ```js
    var x = 1; // x 초기화
    console.log(x + " " + y); // '1 undefined'
    var y = 2;
  ```
  - 이 코드는 초기화 단계 전에 이미 var = x와 var = y가 선언이 된 후 호이스팅 단계로 올라간다(호이스팅 단계의 끝). 그 후(코드 실행 과정의 시작) 1. `x = 1`이라는 초기화 과정이 실행되기 때문에 x = 1이 되고,`console.log(x + " " + y);`가 실행이 되는데 여기서 x = 1은 정상적으로 출력, 공백 그리고 y 값은 undefined로 나타난다. y 값은 선언은 되었지만 초기화 된 값이 아직 없기에 undefined 선언(오류가 아님)되고 그 후에 y = 2라는 초기화가 실행된다.

### 스코프 체이닝

  스코프 체인 과정은 코드가 실행되는 과정에서 식별자를 찾기 위해 자신이 속한 영역에서 부터 상위 영역까지 그 식별자를 찾기 위해 발생하는 현상
    - 이와 같은 현상은 성능에 문제를 줄 수 있기 때문에 별로 좋지 않다

  그렇기 때문에 코드를 작성할 때는 
    - 변수 선언/초기화 및 함수 선언/표현식을 영역(scope)의 최상위에 작성하는 것이 바람직하다

  ---

## IIEF(Immediately Invoked Function Expression)

  IIFE는 자바스크립트의 기능으로써 함수가 선언되면 바로 그 함수를 실행시키는 것을 말한다(메모리에 저장하지 않는다). 이 기능은 두 가지의 주요 부분들을 포함하고 있는데, 하나는 익명함수를 사용하는 것이고 또 한가지는 선언과 동시에 함수를 실행시키는 것이다.

  - 첫 번째의 예시
    ```js
      (function () { 
      var aName = "Barry";
      })();
      // Variable name is not accessible from the outside scope
      aName // throws "Uncaught ReferenceError: aName is not defined"
    ```
    이와 같이 작성된 코드는 외부에서의 접근이 불가능하고 함수 내에서만 접근이 가능하다

  - 두 번째의 예시
    ```js
      var result = (function () { 
      var name = "Barry"; 
      return name; 
      })(); 
      // Immediately creates the output: 
      result; // "Barry"
    ```
    이 코드는 함수의 결과만 반영하고 그 안에 선언된 값들은 저장하지 않는다.


---

## 클로저(closure)

  closure는 자바스크립트의 특성으로 독립적인 변수를 창조하는 함수를 말한다. 클로저에 정의된 함수는 그것이 작성된 환경을 기억한다.
  ```js
  function countUp() {
    var count = 1;
    return count++;
  }
  ```
  - 이 경우에는 함수에서 정의된 값들이 함수 실행 후 없어지기 때문에 매번 결과값이 1이 나온다. 항상 새로운 함수를 실행시키는 것과 같은 효과.

  ```js
  var count = 1;

  function countUp() {
    return count++;
  }
  ```
  - 이 경우에 함수를 실행시키면, 함수의 밖에서 선언된 count에 함수의 리턴 후 결과가 저장되기 때문에 이 장소 영역을 `lexical scoping`이라고 한다

### lexical environment

  모든 함수에는 실행 컨텍스트가 있는데, 실행 컨텍스트는 해당 함수 내의 변수의 해당 부모 환경에 대한 참조를 의미하는 환경으로 구성된다. 상위 환경에 대한 참조는 내부 함수가 작성된 범위 외부 또는 내부에서 호출 여부에 관계없이 상위 범위의 모든 변수를 모든 내부 함수에서 사용할 수 있게 한다.
  따라서 함수가 사실상 환경(해당 환경에 정의된 변수)에 대한 참조를 가지고 있기 때문에 함수가 이 환경(또는 영역)을 '기억'하는 것처럼 보인다.
  모든 실행 컨텍스트에는 어휘 환경(lexical environment)이 있는데, 이 어휘 환경은 식별자 바인딩(즉, 변수 및 관련 값)을 보유하고 있으며 외부 환경에 대한 참조도 가지고 있다.
  각 환경이 접근 할 수 있는 일련의 식별자를 '범위(scope)'라고 하며 이러한 범위를 `scope chain`을 통해 계층적 환경 체인에 중첩 할 수 있다.

### 실행 컨텍스트(Execution Context)

  ECMAScript 사양에서 코드의 런타임 평가를 추적하는 데 사용되는 추상개념이다. 이것은 코드가 처음 실행되거나 실행 흐름이 함수 본문에 들어갈 때 전역 컨텍스트 일 수 있다.

  글로벌 실행 컨텍스트 (Global Execution Context)
  `var x = 9;`

  함수 실행 컨텍스트 (outerFn: Execution Context)
  ```js
  function outerFn()  {
    var y = 12;
    // 함수 실행 컨텍스트 (innerFn: Execution Context)
    function innerFn()  {
      var z = 6;
      return x + y + z;
    }
    return innerFn;
  }
   ```
   
   어느 시점이든 하나의 실행 컨텍스트만 실행 될 수 있습니다. 이것이 JavaScript가 "단일 thread"인 이유이다. 즉, 한 번에 하나의 명령만 처리 할 수 있다. 일반적으로 브라우저는 '스택'을 사용하여 이 실행 컨텍스틀 유지 관리한다. 스텍은 LIFO(Last In First Out) 데이터 구조이다. 

   스택에 푸시(push)한 마지막 것이 먼저 꺼내진다(배열을 예로 들었을 때 push는 배열의 마지막에 삽입되게 되고, pop할 때는 가장 마지막 열부터 빼오기 때문이다). 스택의 맨 위에 요소만 삽입하거나 삭제할 수 있기 때문이다. 현재 또는 '실행 중인' 실행 컨텍스트는 항상 스택의 맨 위에 있는 항목이다. 실행 중인 실행 컨텍스트의 코드가 완전히 평가되면 최상위 항목이 팝(pop) 된 다음 실행 항목이 실행 컨텍스트를 실행하는 것으로 간주된다.

   또한 실행 컨텍스트가 실행되고 있다고 해서 다른 실행 컨텍스트를 실행하기 전에 실행이 완료되어야 한다는 것을 의미하지는 않는다. 실행 중인 실행 컨텍스트가 일시 중단되고 다른 실행 컨텍스트가 실행 중인 실행 컨텍스트가 되는 경우가 있다.

   일시중단 된 실행 컨텍스는 나중에 중단 된 부분을 선택한다. 한 실행 컨텍스트가 이와 같이 다른 컨텍스트로 대체 될 때마다 새 실행 컨텍스트가 만들어져 스택에 푸시되고 현재 실행 컨텍스트가 된다.





---

수업 내용 노트

## 반응형 웹 디자인

이원화 전략 vs one source multi use
  
### 이원화 
  - 모바일과 웹브라우저를 따로 서비스하고 관리


### one source multi use  
  - 유연한 레이아웃 제공으로 환경에 상관없이 최대한 같은 사용자 경험을 제공하려고 한다

### 반응형 웹의 필요성 대두
  - Flexible vs Adaptive
    - flexible은 고무줄 처럼 화면 크기가 변하는 순간마다 레이아웃이 커지고 준다고 하면, adaptive는 화면이 어느 화면크기가 되었을 때 화면 크기의 변화를 준다

    - flexible는 방대한 콘텐츠가 필요할 수 있다 
      - 그래서 최대한 레이아웃은 간단하고 콘텐츠의 양도 적게 유지하는 것이 좋다

### 데스크탑 vs 모바일 : 무엇을 먼저 설계할까?
  - 모바일 먼저 설계 후 접근하는 것이 효과적

### media queries
  
### responsive image (콘텐츠 이미지)
  ```css
  img {
    max-width : 100%;
    height: auto;
  }
  ```

이미지를 사용할 때 성능 고려
  - 벡터 형식의 이미지인 `svg`형식이 각광받고 있다

