# React: udemny online lecture

강의와 관련된 개발환경 설정

JSX : 부분적인 템플릿 혹은 변형된 자바스크립트로써, 자바스크립트 안에 HTML의 소스코드를 사용할 수 있게 해준다. 바벨과 같은 컴파일러를 통해서 바닐라 자바스크립트로 변환된 뒤에 화면에 표시된다.

React component를 화면에 그리기 위해서는:

1. React라는 라이브러리를 불러와야 하기 때문에 `import React from 'react';`를 해주는 것을 잊어서는 안된다.
2. 그리고 App.js(혹은 index.js)를 DOM에 붙인 뒤 화면에 그려주어야 하기 때문에 ReactDOM을 `'react-dom'`으로 부터 import를 해와야 한다.

DOM에 컴포넌트를 렌더하기 위해서는 컴포넌트를 인스턴스화 해야한다. 인스턴스화를 하기 위해서는 ReactDOM.render()안에 `<App />`이라는 인스턴스(App이라는 클래스가 아닌)를 렌더하라고 지정해주어야 한다.

인스턴스를 지정해주었다고 해서, 렌더가 되는 것이 아니다. 그 이유는 어디에다가 렌더를 해주어야 하는 지도 지정해주어야 하기 때문이다. 이는 index.html내에 있는 root를 찾아서 지정해주면 된다.

<!-- 섹션 1, 챕터 12 부터 시작 -->

# 2018-12-27

우리가 app을 만들 때, 어떻게 컴포넌트를 구성할 지 정해야 한다.

1. app 상단의 검색 바 컴포넌트

- 이는 검색하는 기능을 가지고 있고, 검색 바를 렌더링 할 것이다

2. app 중간에 비디오를 플레이하는 컴포넌트

- 역시 기능과 렌더링

3. 비디오의 프리뷰를 보여주는 컴포넌트

- 비디오의 프리뷰 썸네일과 타이틀을 포함

4. 3번의 비디오 프리뷰들을 포함하는 리스트를 보여주는 컴포넌트

5. 그리고 위의 4가지 모두를 포함할 하나의 전체 컴포넌트

파일 당 하나의 컴포넌트를 만들어야 한다.

## Youtube API를 사용해서 비디오 재생하는 컴포넌트의 생성

npm을 통해 youtube-api-search를 설치. 설치 시에 `--save`를 선언하면, 이는 package.json에 파일을 자동으로 저장해달라는 의미이다.

컴포넌트를 생성한 뒤에 export를 하지 않으면, 다른 컴포넌트에서 불러와 사용할 수가 없다. 그렇기 때문에 export를 하는 것을 잊지 말자!

```js
// 무언가를 export 할 때,

const SearchBar = () => {
  return <input />;
};

const foo = 5;

export default SearchBar;

// 위와 같은 선언은 foo는 제외한 SearchBar만 export 한다.
```

무언가를 import 해올 때, npm에서 설치된 패키지같은 경우에는 `from 패키지 이름`만 선언해줘도 되지만, 컴포넌트 같은 경우에는 import를 하려고 하는 파일의 상대 경로를 지정해서 불러와주어야 한다.

index.js에 search_bar.js를 렌더링 한다. index.js는 search_bar.js를 렌더링하고, 이 렌더링의 결과를 App 컴포넌트 안에 렌더링 한다. 이 App.js 컴포넌트는 div에 렌더링 할 것이고, 이 div는 index.js파일의 container라는 컨테이너 안에 위치한다.

리액트 컴포넌트의 형태

1. 함수형 컴포넌트
2. 클래스 컴포넌트

함수형 컴포넌트보다 클래스 컴포넌트가 더 많은 기능(상태라던지..)을 포함할 수 있다.

```js
// class component의 생성
// extends React.Component는 말 그대로
// 리액트 컴포넌트로부터 모든 기능을 제공받으라는 것이다
class SearchBar extends React.Component {}
```

함수형 컴포넌트로 시작할 지, 클래스형 컴포넌트로 시작할 지에 대한 고민은 무척 어렵다...

## Detecting handling events

`<input />` 안에:
`onChange`: 모든 HTML 인풋 요소에 change event가 발생하면 `onChange={함수}` 함수가 실행된다. 여기서 `onChange`는 prop이고 이 안에 함수를 쓰게 된다.

이벤트 핸들러 안에 들어갈 요소로써 이벤트 객체가 있는데 이는 e 또는 event라 정의할 수 있고, 어떠한 이벤트가 발생했는지를 알기 위해서는 `event.target.value` 등의 선언을 통해 입력이 되고있는 input 등을 바로 확인할 수 있다.

핸들러를 정의해줄 수도 있으나, 바로 적용시킬 수도 있다.

```js
// input 컴포넌트 내에 바로 적용시킨 것
class SearchBar extends Component {
  render() {
    return <input onChange={e => console.log(e.target.value)} />;
  }
}
```

## 상태 관리

함수형 컴포넌트는 상태를 가질 수 없고, 오직 클래스형 컴포넌트만 상태를 가질 수 있다.

```js
constructor(props) {
    super(props);

    this.state = {
      term: ""
    };
  }
```

위는 React component에서 상태를 정의하고 싶을 때 만드는 contructor이다.
Component가 constructor 함수를 가질 때:

- 부모 클래스에 메소드를 미리 정의했을 때 => component:
  - super를 호출하면서 이 부모 클래스의 메소드를 호출할 수 있다.

<!-- 챕터 18부터 다시 시작 -->
2019년 1월 14일

필요에 의해 Redux 부분부터 듣기로 했다. 챕터 34부터 시작.

## 리덕스 

### 리덕스는 왜 필요하고, 우리가 사용하면서 얻는 이점이 무엇일까?

리덕스는 앱을 표현할 수 있는 모든 데이터를 가지고 있는 컨테이너라고 볼 수 있다. 리액트는 이런 데이터를 뷰로 변환하여 보여주는 역할을 담당한다고 보면 된다. 

리덕스는 이 모든 데이터를 한 객체(상태 또는 state)로 집중시킨다. 

만약, 간단한 카운터(+, -와 현재 카운트를 보여주는)가 존재한다고 할 때, 이를 데이터를 담고 있는 컨테이너와 뷰를 담고 있는 컨테이너로 나눈다고 가정해보자. 그렇게 되면 데이터를 담고 있는 컨테이너에는 카운터의 현 상태를 담고 있는 current count라는 데이터가 들어있을 것이고, 뷰를 포함하는 컨테이너에는 current count를 보여주고, number change를 보여주는 뷰들이 포함되어 있을 것이다. 이 두 컨테이너들이 합쳐지면 사용 가능한 앱이 되는 것이다. 

리덕스는 앱의 상태를 담고 있거나, 어떠한 데이터를 뷰에 그릴지에 관한 정보를 담고 있다. 

---

리액트는 뷰를 컨트롤하고, 리덕스는 데이터를 컨트롤한다고 보면 쉽다. 

틴더라는 앱을 예로 들어서 리덕스와 리액트의 역할 분담을 이해해보자. 

**데이터를 담고 있는 컨테이너**
  - 사용자들(사용자의 이미지와 채팅 기록을 포함)
  - 대화를 하고 있는 현재 사용자들 목록
  - 지금 현재 보이고 있는 대화의 내용 
  - 리뷰가 되어야 하는 사용자들 목록(아직 다른 사용자들에게 보여지지 않음)
  - 사용자들이 현재 보고 있는 이미지의 데이터

**뷰를 담고 있는 컨테이너**
  - 이미지 카드 
  - 좋아요, 싫어요 버튼 
  - 대화 목록들 
  - 텍스트 아이템들(개인 메시지들) 
  - 텍스트 리스트(채팅 메세지들의 목록)

애플리케이션의 상태, 즉 자바스크립트의 한 객체에 애플리케이션이 필요한 모든 데이터와 관련된 상태들이 담겨있다고 보면 된다. 

--- 

### 리듀서 

리듀서는 하나의 애플리케이션 상태를 반환하는 함수이다. 리덕스는 여러가지의 상태를 가질 수 있고, 이에 따라서 여러 종류의 리듀서가 생길 수 있다. 

책을 보여주는 앱이 있다고 가정하자. 

**데이터를 포함하고 있는 컨테이너(리덕스)**
  - 책 리스트 
  - 현재 선택된 책 

**뷰를 포함하고 있는 컨테이너(리액트)**
  - 책 리스트를 보여주는 뷰 
  - 리스트가 포함하고 있는 아이템을 보여주는 뷰
  - 아이템의 상세 정보에 관한 뷰 

책 리스트와 현재 선택된 책에 관한 각각의 리듀서가 존재해야 하기 때문에 2개의 다른 리듀서들이 필요할 것이다. 

```js
// Application State - Generated by reducers

{
  books: [ {title: 'Harry Potter'}, { title: 'JavaScript'}], // Book Reducer
  activeBook: { title: 'JavaScript: The Good Parts'}
} // ActiveBook reducer

```

이제 상태의 값을 생성하는 함수를 만들어 볼 것이다.

리듀서를 위한 파일을 생성한 후, 함수를 작성한 뒤에 그 함수를 export하자. 그렇게 되면, 다른 파일에서 이 리듀서가 작성된 파일을 import할 때(책의 리스트가 있는) 자동적으로 책의 리스트가 담겨있는 리듀서를 불러올 것이다. 

그렇기 때문에 이것을 두 개의 작업으로 볼 수 있다.
1. 리듀서를 만드는 작업
2. 이 리듀서를 다른 파일들에 연결해주는 작업

이 리듀서를 리듀서 폴더 안에 있는 index.js(combineReducers라는 함수가 정의 된 곳)에 import 해야 한다. 

<!-- 1월 19일 챕터 40 -->
## 챕터 40

리덕스와 직접적인 연결이 없다면 이것은 view(dumb) component이다. 

인강의 예제에서 왜 book-list를 container로 만들지에 대한 과정을 알아보자.

예제 내의 app.js가 모든 상태를 가지고 가장 최상위에 위치하지 않겠냐는 질문을 던질 수가 있는데, app.js는 사실 book list에 대해 신경을 쓰지 않는다고 볼 수 있다. book-list가 book list에 대해 신경을 쓰는 것이다. 그리고 active book에 관한 것도 book-detail이 신경을 쓰는 것이다. 

app.js는 책의 리스트나 어떤 책이 선택되었는 지에 대한 것은 신경쓰지 않고,
여러 다른 페이지를 렌더해달라는 것이 전부이다. 그렇기 때문에 BookList와 BookDetail이 redux와 직접 연결되는 smart container가 될 것이다. app.js는 dumb component의 역할을 하는 것이다. 

그렇기 때문에 컨테이너(container component or smart component - 리덕스가 가진 상태에 직접적으로 접근할 수 있는 컴포넌트)를 생성할 때는 최상위 컴포넌트가 기능과 관련된 상태를 가지고 있어야(리덕스와 연결이 되어야 한다) 한다는 것이다. 자식 컴포넌트가 상태를 필요로 해도 그와 연결된 최상위 컴포넌트만 리덕스와 연결되어야 한다.  

<!-- 챕터 42 -->
## 챕터 42

그 후 `mapStateToProps(state)`라는 state을 매개변수로 받는 함수를 작성해 준다. 이 함수를 작성하는 이유는 이 애플리케이션의 상태(책의 리스트를 담은 배열, 현재 선택된 책)를 매개변수로 받는다. 이 함수에서 반환되는 값은 BookList 내에 props로 보여질 것이다.

`import { connect } from 'react-redux'` 해준 후,
`export default connect(mapStateToProps)(BookList)`와 같은 방식으로 export 시킨다. 

connect는 함수와(mapStateToProps) 컴포넌트(BookList)를 받아서 컨테이너를 생성한다. 이 컨테이너는 리덕스에 의해 관리되고 있는 상태를 인식하는 컨테이너이다. 

mapStateToProps 내에서 반환되는 것은 this.props로 접근할 수 있다. 이 함수는 리액트와 리덕스를 이어주는 아주 중요한 역할을 한다. 이 예제의 경우에서는 books라는 키를 가지고 state.books라는 값을 가진 것을 반환한다. state.books는 reducer에서 정의되는 books를 사용하기 위해 저렇게 쓰여졌다. 

connect를 사용해서 컨테이너를 생성하면,
1. 상태가 바뀌는 일이 발생한면 렌더가 다시 발생한다. 
2. 상태가 바뀌는 일이 발생하면, mapStateToProps내에 선언된 객체는 컴포넌트에 props로 할당된다.

<!-- 챕터 43부터 진행해야 함. -->
## 챕터 43

챕터 43은 위의 내용을 다시 복습하는 구간.

리덕스는 상태(데이터를 저장하는 컨테이너)를 제공하고, 리액트는 뷰를 제공한다고 볼 수 있다. 앱의 상태는 리듀서 함수에 의해 생성된다. 여기서는 reducer_books.js를 생성하여 책에 관한 정보가 담긴 객체들이 있는 배열을 반환시켰다. 이 book 리듀서를 리듀서 폴대 안에 생성되어 있는 index.js(리듀서를 총괄하는 js 파일) 내의 combineReducer 내에 선언해준다. 이 리듀서 함수는 books라는 키를 가지고 BooksReducer(reducer_books.js로부터 오는)라는 값을 가진, 이 객체 안에 선언된 것을 이 애플리케이션의 전역 상태에 선언하게 된다. 

그 이후에 books_list라는 컴포넌트를 생성한 뒤, 이 컴포넌트가 이 애플리케이션의 상태에 대해 인식해야한다는 것을 알고는 리덕스와 연결하기로 결정했다(컨테이너로 만들기로 결정함). 컨테이너(즉, 스마트 컴포넌트)로 만들기 위해서는 우선 connent를 임포트 하고, 그 뒤에 mapStateToProps 함수를 작성하고, export default connect를 이용해 리덕스와 연결한다. 

book_list를 컨테이너로 만들기로 한 결정의 배경은 오직 이 컴포넌트만이 앱의 전역 상태에 있는 BookList에 대해 알아야하기 때문이다(app.js같은 경우에는 BookList를 알 필요가 없다).

<!-- 챕터 44 액션과 액션 생성자 -->
## 챕터 44

이 예제의 문제가 하나 있다. 그 문제는 book reducer는 항상 같은 배열만 반환한다는 것이다. 지금 이 상태는 100% static(정적)인 상황이다. 시간이 지나도 지금 상태로는 이 상태에 변화를 줄 수 없다. 나중에 선택된 책이 어떤 것인지를 표시하게 해주려면 결국 상태의 변화를 나타낼 수 밖에 없다. 그렇기 때문에 동적인 상태도 표현할 수 있도록 코드를 작성해야 한다. 이를 위해서 action과 action creator를 사용해서 구현한다. 

**리덕스 action의 라이플 사이클**

리덕스 내에서는 대부분의 모든 상황에서 사용자가 직접적 혹은 간접적으로 이벤트를 발생시켰을 때 action이 작동한다. 버튼을 클릭하거나, 드랍다운 메뉴를 펼치거나 하는 것이 직접적인 이벤트 발생의 예라면, 간접적으로는 Ajax통신이 완료된다던지, 페이지의 로드가 완료된다던지가 될 수 있다. 이러한 행동들은 action creator를 선택적으로 호출할 수가 있다.

Action creator는 action을 반환하는 함수이다. 예를 들어, 사용자가 목록에서 책 하나를 클릭했을 때, action creator를 호출하게 되는 것이다. 그렇게 되면 action creator는 action을 반환하게 되는데, 이 action은 자동적으로 모든 리듀서들에게 전송이 된다. 리듀서들은 action의 종류에 따라 어떤 상태를 반환할 지 선택을 할 수가 있다. 만약에 여기서 상태를 반환하기로 한다면, 이 새로 반환된 상태는 애플리케이션의 상태에 넣어지게 되고, 이 상태의 추가 때문에 리액트가 다시 렌더링을 하게 된다. 

Action은 객체 안에 타입을 포함하고 있다. 그리고 action을 설명할 수 있는 데이터도 포함할 수 있다. 

리듀서에 action이 전송될 때, 그 안에서는 switch(action type) 선언문이 action이 어떤 타입을 가지고 있는지에 따라 실행된다.

그리고 만약 선택된 타입에 무엇을 반환할지 정해져 있다면, 그것을 반환하게 될 것이다. default 설정은 현재의 상태를 그대로 반환한다. 

그리고 이 스위치 문에서 반환되는 값이 애플리케이션의 새로운 상태 값으로 재할당이 된다.

>all reducers processed the action and returned new state. New state has been assembled. notify containers of the changes to state. On noticification, containers will render with new props.


<!-- 1월 20일 -->
## 챕터 45

이제 책을 클릭했을 때, 선택된 책이 보이도록 구현하기 위해서 actions 폴더 내에 index.js에 이와 관련된 action을 작성할 것이다. 

index.js 안에 selectBook이라는 book을 매개변수로 받는 함수를 작성하고 적용을 해야한다. 적용을 할 때, 이 함수를 book_list.js에 import하고 핸들러로 넘겨준다고 생각할 수도 있지만, 이 일은 그렇게 간단하지 않다. 

선언된 action으로 인해 반환되는 것이 모든 리듀서들을 거치도록 구현을 해야한다. Action creator가 리덕스에 연결되도록 해주어야 한다는 것이다.

book_list.js를 connect 훅을 사용해서 리덕스와 연결시켰던 것 처럼, 여기에다가 다시 bind를 통해 action creator와 연결해 줄 것이다. 

book_list.js로 돌아온 뒤, selectBook을 import 해주고, 그 다음에 bindActionCreators라는 훅을 redux로부터 import 한다. 

그리고 mapStateToProps 다음에는 mapDispatchToProps 함수를 작성하는데, 이 함수의 역할은 selectBook이 호출되었을 때 반환되는 값이 모든 리듀서들을 거치도록 하는 역할을 하도록 만들어주는 함수이다. 

mapDispatchToProps를 통해 반환되는 것들은 BookList container에 props로 전달될 것이다.

<!-- 챕터 46 -->
## 챕터 46


mapDispatchToProps를 통해 selectBook이 반환될 것이기 때문에 이것`(this.props.selectBook)`을 위에 `<li>`에 onClick 이벤트를 통해 사용할 수가 있다. 

index.js(actions 폴더 내의)로 돌아와서 selectBook에 타입을 정의해주려고 한다. return{} 내에 타입은 'BOOK_SELECTED'를 값으로 정해주고, payload는 book으로 정해줄 수 있다. 타입은 항상 대문자로, 그리고 대부분은 string을 사용하며 단어 별로 `_`를 사용하여 나누어줄 수 있다. 


<!-- 챕터 47 -->
## 챕터 47

이제 해야될 것은 active_book을 위한 리듀서를 작성하는 것이다.

리듀서는 state과 action을 매개변수로 받는다. 매개변수에 들어오는 state는 전역의 state가 아닌, 하나의 리듀서가 관련하는 state만 취급한다. 

만약에 작성된 리듀서와 관련없는 state이 들어오게 되면, 그냥 default state을 반환하도록 작성해줘야 한다. 

선택된 책을 보여주는 리듀서를 작성 시, 사용자가 아무 선택을 하지 않았을 시에 넘겨줄 default state이 필요하다. 리듀서는 undefined를 상태로 넘겨주지 않고 에러를 발생시키기 때문에 default state을 항상 설정해주어야 한다!

이 예제에서는, 매개변수 state에 null을 설정해준다. `state = null`(ES6에 추가된 기본값 설정법)을 해주면, state가 undefined가 반환되어도 이를 null로 반환해 줄 것이다. 

리듀서 안에서 값을 변경하는 행위를 해서는 안된다. 항상 오염되지 않은 객체를 반환해야 한다. 

리듀서 index.js에 ActiveBook을 import하고 combineReducers안에 선언해주자. 여기서, 키로 정의되는 객체가 바로 전역 상태의 키가 된다. 
---

**argument vs parameter**

parameter(매개변수)는 함수에 어떠한 값이 넘어오는지를 뜻해주고 argument(인자)는 함수로 넘어오는 실제적인 값을 뜻한다!

---

<!-- 챕터 48 -->
## 챕터 48

이제 선택된 책을 보여주는 book detail view를 만들 것인데, 이를 결정하기 위해서는 컴포넌트(VC)를 만들 것인지 컨테이너(CC)를 만들 것인지 결정해야 한다. 여기서는 우리가 어떤 책들이 있는지 알고, 언제 변경이 되는지 알기 때문에 이 컴포넌트는 리덕스에 연결될 수 있도록 컨테이너로 승격되어야 한다! 

결국, 위의 뜻은 app.js는 책의 리스트와 책의 자세한 사항(어떤 책이 선택되었는지)을 뷰로 보여주기만 할 것이기 때문에, 어떤 책이 선택되었는지는 book detail만 알고 있으면 된다. 그렇기 때문에 우리는 active_book 컴포넌트를 컨테이너로 만들 것이다. 

book-list를 리덕스와 연결했던 것 처럼 똑같이 하면 된다.

<!-- 챕터 49 조건부 렌더링! -->
## 챕터 49

리듀서가 실행될 때, 어떤 일이 일어나는 지를 알아보자. 

애플리케이션이 처음 실행될 때:
1. 액션이 들어온다. 타입이 뭔지는 모른다(이 예제에서는 앱이 켜졌을 때 책이 바로 선택되지 않기 때문에 어떠한 타입도 없다고 볼 수 있다).
2. 그렇기 때문에 일단 `return state`문이 실행된다. 
3. default값에 null을 넣어주었기 때문에 active book의 상태는 null값이 될 것이다. 
4. 그렇기에 book-detail 내에 작성한 this.props.book.title도 없는 것(`null`이니까)으로 간주 될 것이다. 이것이 에러를 발생시킨다.  

위의 상황을 방지하기 위해서, book-detail 내의 렌더 메소드에서 체크를 하는 코드를 작성해 줄 수 있다. 

<!-- 챕터 50 -->
## 챕터 50

기억하고 넘어가야 할 것

1. 리덕스는 애플리케이션의 상태를 관리하는 역할을 한다. 앱의 상태와 컴포넌트의 상태는 다르다! 이 둘은 완전 다르다. 이 앱의 상태는 리듀서들로 구성된다.

2. 리듀서 index 파일 안에 컨테이너의 상태를 담게 된다. 한 컨테이너의 모든 상태는 리듀서 index 파일 내에 선언된 이름으로 사용할 수 있다.

3. 리듀서는 애플리케이션의 상태를 바꾸는 역할을 한다. 액션이 dispatch되면 모든 리듀서들에 보내지면서 맞는 type이 있는지를 확인한다.

4. action creators는 action을 반환하는 매우 간단한 객체이다. 액션은 항상 타입이 있어야하고, payload가 필요하다. 관례적인 것이다.


<!-- 리덕스 중급과정 : 미들웨어 챕터 51부터 -->
## 챕터 51

무엇을 어떻게 계획해서 만들 것인가?

- 날씨 정보를 제공해주는 앱을 만들 것이다.
  1. 유저들은 서치바를 통해서 도시를 검색할 수 있다.
  2. 검색을 하면, API에 요청을 보내서 다음 5일간의 날씨 정보를 받아올 것이다.
  3. 유저들은 많은 도시 정보들을 한번에 확인할 수 있다.

리덕스가 모든 데이터 통신과 관련된 로직을 가져야하고, 리액트는 뷰와 관련된 역할만 해야한다. 

<!-- 챕터 52 -->
## 챕터 52

## 컴포넌트 셋업 
0. App 
  - 모든 하위의 컴포넌트를 렌더할 컴포넌트.

1. SearchBar 컴포넌트 
  - search input, search button을 포함한 상단에 위치할 컴포넌트 
  - 이곳에서 리덕스 액션이 발생할 것이다.(featching data)

2. ForecastList 컴포넌트
  - 리스트와 리스트 아이템을 한 컴포넌트에 넣어서 보여줄 것 같다. 

3. Chart 컴포넌트 
  - 차트에 관한 정보를 받아와서 여러개의 다른 정보를 표현하는 컴포넌트로, 재사용할 수 있도록 생성할 것.

## 컴포넌트가 컨테이너가 될 것인지, 컴포넌트가 될 것인지를 정하자 


### SearchBar
  - 유저가 입력하는 도시의 정보를 요청해야하기 때문에 컨테이너가 되어야 한다. 

  - SearchBar 내에 사용되는 input은 controlled field(input에 입력되는 내용을 리액트(VC) 컴포넌트 상태에서 관리)화 시켜서 사용할 것이다. 

  - 이벤트 핸들러 생성 시, this.setState과 같은 무언가를 가리키는 코드를 사용할 때에는 bind를 생성자 안에서 연결해야 하는 것을 잊지 말자!

  - 유저가 엔터 혹은 submit 버튼을 눌렀을 때, 서버로부터 날씨 관련 데이터를 받아오는 로직이 필요하다.



<!-- 챕터 56, 미들웨어 -->
## 챕터 56

## 미들웨어는 무엇인가?

미들웨어는 액션을 받은 함수들이다. (기본적으로) 액션의 타입과 payload에 따라 미들웨어는 이것들을 통과시켜줄 수도 있고, 아니면 콘솔 로그를 찍어보거나 아예 작동을 멈추게 할 수도 있다. 리듀서에 액션이 닿기 전에 원하는 동작을 추가한 다음에 리듀서로 넘겨주는 것이라고 볼 수 있다. 

결국 미들웨어는 액션이 리듀서로 가기 전에 검사를 하고, 액션들이 통과할 수가 있는지 아니면 추가되야 하는 작업이 있는지 등을 확인한다.

미들웨어를 사용하기 위해, npm을 통해 redux-promise를 설치했다!

<!-- 챕터 57, Axios로 Ajax 리퀘스트 -->

## 챕터 57

이번 섹션에는 일단 리퀘스트를 보내는 것에 집중한다. 

애플리케이션의 상태는 오직 리듀서와 액션들을 통해서 바꾸기 때문에, 날씨 정보를 불러오거나 애플리케이션의 상태를 바꾸기 위해서는(날씨 정보를 업데이트 하거나 추가하는 등의) 액션을 dispatch(액션 크리에이터를 부르기) 하고 Ajax 리퀘스트를 해야한다. 

액션 크리에이터들은 항상 타입을 가지고 있는 액션이라는 객체를 반환해야 한다. 

지난 번에는 type에 직접 문자열 값을 `'FETCH_WEATHER'` 이런 식으로 명해줬었는데, 이제는 `export const FETCH_WEATHER = 'FETCH_WEATHER'`과 같은 식으로 변수로 선언해주고 그것을 export하여 다른 곳에서도 사용될 수 있도록 해줄 것이다.

그럼 왜 이런 것(전역에서 사용할 수 있도록 변수를 선언해주고 export하는)을 하는 것일까?
  - 액션 크리에이터와 리듀서 사이에서 액션 타입을 항상 일정하게 해주려고 하기 위함이다.
  - 혹시 누군가가 action에 오타를 내어서 잘못 값을 입력하게 되는 등의 일을 방지하기 위함이다.
  - 그리고 나중에 그 변수의 값을 수정함에 있어서도 매우 간편하다. 문자열 값으로 type일 지정해 주었다면, 액션과 리듀서에서 모두 똑같게 수정을 해주어야 할 텐데, 변수로 정해놓고 사용하면 그 변수의 값만 설정을 바꿔주면 여전히 같은 변수명으로 사용되고 있을 것이니까 말이다. 


payload는 전에도 설명했듯이, action과 관련된 정보를 포함할 수 있는데, 여기다가 axios request를 get한 정보를 같이 담으면 될 것이다.

```js
import axios from "axios";

const API_KEY = "04e35625f77ea2b0f4bcd776054f8a9e";

const ROOT_URL = `http://api.openweathermap.org/data/2.5/forecast?q=London,us&appid=${API_KEY}`;

export const FETCH_WEATHER = "FETCH_WEATHER";

export function fetchWeather(city) {
  const url = `${ROOT_URL}&q=${city},us`;
  const request = axios.get(url);

  return {
    type: FETCH_WEATHER,
    payload: request
  };
}

```

<!-- 챕터 58 -->
## 챕터 58

이제 SearchBar를 redux와 연결해서 사용자가 도시를 검색창에 입력했을 때 action을 보내주는 코드를 작성해야 한다. 

그러기 위해서는 필요한 hook들을 import한 뒤에, 코드 마지막에 mapDispatchToProps 함수를 작성해야 한다. 

```js

function mpaDispatchToProps(dispatch) {
  return bindActionCreators({ fetchWeather }, dispatch);
}

// SearchBar를 export default하는 것을 지우고 이 밑에 선언한다.

export default connect(
  null,
  mpaDispatchToProps
)(SearchBar);

// null을 선언해주는 이유는 mapDispatchToProps는 항상 2번째 argument로 넘겨져야 하기 때문이다. 
```

`onFormSubmit`을 bind 해주는 것을 잊으면 안된다!

<!-- 챕터 59 -->
## 챕터 59

reducer_weather.js 파일을 리듀서 폴더 내에 생성해주고, 이를 폴더 내의 index.js에 import 하자. 그 후, weather reducer를 combineReducers 내에 선언하자.

axios는 promise를 반환하는데, action creator에서는 payload가 이 request에 대한 promise를 반환하는 곳이 된다.

redux promise는 미들웨어로의 역할을 하면서 payload property를 확인해보면서, 이 payload에 promise가 들어오면 모든 action을 멈추고 (request가 끝나고 나면) promise를 분석한 결과를 리듀서로 변환하여 보내는 것이다. 

<!-- 챕터 60 -->
## 챕터 60

이전 챕터에서 redux-promise가 알아서 promise를 분석해서 데이터를 넘겨주기 때문에, 우리는 이 데이터와 관련된 작업만 진행해주면 된다. 우리가 정작 필요한 데이터는 action.payload.data로 넘어오는 자료들이기에, 이 데이터만 저장하여 사용하면 된다.

우리는 도시의 정보를 배열안에 넣는 것이 좋을 것이다. 그래서 reducer_weather.js의 초기 state 값을 null로 설정했던 것을 `[]`로 해주자. 

```js
import { FETCH_WEATHER } from "../actions/index";

export default function(state = [], action) {
  switch (action.type) {
    case FETCH_WEATHER:
      return [action.payload.data];
  }
  return state;
}

```

위와 같이 코드 작성을 해주면, 이제 유저들이 새로운 검색을 시도할 때마다 그 특정한 도시에 정보만 배열 안에 넣게 만드는 구조임을 알 수 있다. 그렇기 때문에, 새로운 정보만 그 때 다시 넣는 것이 아니라 이미 검색된(저장된) 정보에다가 새로 검색되는 도시의 정보도 추가시키는 방식으로 코드 작성을 해주어야 한다. 

배열에 새로운 정보를 추가하고 싶다고 해서, `state = 'something'`이나 기존값을 mutate(기존의 것에서 뻗어나오는 것이 아닌)해서 복사하면 안되고, setState을 이용하거나 완전히 새로운 것을 만들어야 한다. 

이 경우에는 새로운 정보를 추가할 때마다 완전히 새로운 배열을(기존의 정보 + 새로 담길 정보) 생성해주는 것이 옳은 방법이다. `concat`을 이용해서 새로운 정보를 추가시킬 수 있다. `concat`은 기존에 있는 배열에 이어 붙이지 않고 매번 새로운 배열을 생성한다. 

```js
// 이렇게 새로운 배열을 생성하며 기존의 데이터에 새로운 데이터를 추가할 수 있다
state.concat([action.payload.data]);

// ES6 syntax를 이용하면...
[ action.payload.data, ...state ]

// 이와 같이 표현해 줄 수도 있다 -> 
// 새로운 배열을 만들어서 action.payload.data를 추가하고 그 안에 이미 존재하고 있던 모든 데이터(...state)도 그대로 추가하라는 뜻의 분해대입이다

```

<!-- 챕터 61 -->
## 챕터 61

도시의 리스트를 불러서 보여줄 수 있는 컴포넌트를 만들 것이다. 이를 컴포넌트로 구성할 것인지, 컨테이너로 구성할 것인지를 생각해보자. 정보를 리덕스에서 받아와야하기 때문에, 이와 관련된 컴포넌트는 컨테이너가 되어야 한다. 

`weather_list.js` 내에 필요한 마크업을 작성 한 뒤, 이를 리덕스와 연결시켜줘야 한다. 

```js
function mapStateToProps(state) {
  return {
    // 리듀서 index.js에 작성한 weather를 가져다 쓰기 때문에 state.weather
    weather: state.weather
  };
}
```

위와 같이 작성한 것을 ES6 syntax를 사용하여 코드를 간결하게 할 수 있다.

```js
function mapStateToProps({ weather }) {
  return {
    weather: weather
  };
}

```

저기서 더 간결하게 하면,

```js
function mapStateToProps({ weather }) {
  return {
    weather // { weather } === { weather: weather}
  };
}
```

와 같이 작성할 수 있다!


<!-- 챕터 62 -->
## 챕터 62

weather(도시들의 날씨 정보를 담고 있다)라는 배열을 mapping하여 화면에 표시해주어야 한다. 

```js
class WeatherList extends Component {
  renderWeather(cityData) {
    const name = cityData.city.name;
    return (
      <tr key={name}>
        <td>{name}</td>
      </tr>
    );
  }
  render() {
    return (
      <table className="table table-hover">
        <thead>
          <tr>
            <th>City</th>
            <th>Temperature</th>
            <th>Pressure</th>
            <th>Humidity</th>
          </tr>
        </thead>
        <tbody>{this.props.weather.map(this.renderWeather)}</tbody>
      </table>
    );
  }
}
```

위와 같이 이 인강에서는 renderWeather라는 함수를 만든 뒤, 그것을 `tbody` 안에 map 메소드를 사용하여 바로 함수를 넘겨주는 방식으로 표시하였다.


<!-- 챕터 64 -->
## 챕터 64

스파크라인이라는 라이브러리를 통해 그래프를 표시하기.

그래서 이 예제의 redux store 안에는... 

```js
weather: [
 { city: {name: 'city a'},
 list: [
   { main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 }

   }
 ] },
 { city: {name: 'city b'},
 list: [
   { main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 },
     main: { temp: 260, humidity: 40, pressure: 55 }}
 ] }
 
//  이것의 반복일 것
]
```

weather.map을 통해 각각의 도시들 정보를 표시할 것이다. 그리고 저 한 도시에 포함되어 있는 여러 온도와 습도 그리고 기압을 한 배열에 묶어야 할 것이다. 예를 들면, `temperature: [260, 260, 260, 260]`의 식으로 말이다(map을 사용하면 된다).

그래프는 Sparklines라는 라이브러리를 통해 작성하였다.

<!-- 챕터 65 -->

## 챕터 65

이제 위 챕터에서는 온도와 관련된 그래프를 그려주었는데, 이 똑같은 코드를 습도와 기압에도 사용해줄 것이기 때문에 재사용 가능한 컴포넌트를 만들어서 코드 중복을 줄여보자.

이 컴포넌트는 데이터를 props를 통해 받아올 것이기 때문에 리덕스와 연결할 필요가 없다. 그렇기에 컴포넌트로 작성하자(chart.js).

chart.js는 아무 상태를 가질 필요가 없기 때문에, 함수형 컴포넌트로 작성해줄 수 있겠다.

<!-- 챕터 66 -->

## 챕터 66

나머지 필요한 데이터도 똑같은 방식으로 맵핑한 다음에 chart.js를 통해 화면에 표시하자.

평균은 lodash라는 라이브러리를 사용해서 표시해보자.

<!-- 챕터 67 -->

## 챕터 67, 68

구글맵 적용과 약간의 CSS 변경 적용.

<!-- 프로젝트 리뷰 -->

## 리뷰

미들웨어(redux-promise)를 사용하여 데이터 타입에 따라 리듀서에 전해줄 정보를 자동적으로 감지하여 처리해주는 것.

mutating을 조심하자. 항상 새로운 값(배열)을 생성하여 사용하는 것으로 코드를 작성해야 한다. 

분해대입 등의 활용.

스파크라인과 같은 라이브러리를 사용해서 프로젝트를 더욱 멋지게 꾸밀 수 있다.
