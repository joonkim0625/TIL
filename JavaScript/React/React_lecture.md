# React: udemny online lecture

강의와 관련된 개발환경 설정

JSX : 부분적인 템플릿 혹은 변형된 자바스크립트로써, 자바스크립트 안에 HTML의 소스코드를 사용할 수 있게 해준다. 바벨과 같은 컴파일러를 통해서 바닐라 자바스크립트로 변환된 뒤에 화면에 표시된다.

React component를 화면에 그리기 위해서는:

1. React라는 라이브러리를 불러와야 하기 때문에 `import React from 'react';`를 해주는 것을 잊어서는 안된다.
2. 그리고 App.js(혹은 index.js)를 DOM에 붙인 뒤 화면에 그려주어야 하기 때문에 ReactDOM을 `'react-dom'`으로 부터 import를 해와야 한다.

DOM에 컴포넌트를 렌더하기 위해서는 컴포넌트를 인스턴스화 해야한다. 인스턴스화를 하기 위해서는 ReactDOM.render()안에 `<App />`이라는 인스턴스(App이라는 클래스가 아닌)를 렌더하라고 지정해주어야 한다.

인스턴스를 지정해주었다고 해서, 렌더가 되는 것이 아니다. 그 이유는 어디에다가 렌더를 해주어야 하는 지도 지정해주어야 하기 때문이다. 이는 index.html내에 있는 root를 찾아서 지정해주면 된다.

<!-- 섹션 1, 챕터 12 부터 시작 -->

# 2018-12-27

우리가 app을 만들 때, 어떻게 컴포넌트를 구성할 지 정해야 한다.

1. app 상단의 검색 바 컴포넌트

- 이는 검색하는 기능을 가지고 있고, 검색 바를 렌더링 할 것이다

2. app 중간에 비디오를 플레이하는 컴포넌트

- 역시 기능과 렌더링

3. 비디오의 프리뷰를 보여주는 컴포넌트

- 비디오의 프리뷰 썸네일과 타이틀을 포함

4. 3번의 비디오 프리뷰들을 포함하는 리스트를 보여주는 컴포넌트

5. 그리고 위의 4가지 모두를 포함할 하나의 전체 컴포넌트

파일 당 하나의 컴포넌트를 만들어야 한다.

## Youtube API를 사용해서 비디오 재생하는 컴포넌트의 생성

npm을 통해 youtube-api-search를 설치. 설치 시에 `--save`를 선언하면, 이는 package.json에 파일을 자동으로 저장해달라는 의미이다.

컴포넌트를 생성한 뒤에 export를 하지 않으면, 다른 컴포넌트에서 불러와 사용할 수가 없다. 그렇기 때문에 export를 하는 것을 잊지 말자!

```js
// 무언가를 export 할 때,

const SearchBar = () => {
  return <input />;
};

const foo = 5;

export default SearchBar;

// 위와 같은 선언은 foo는 제외한 SearchBar만 export 한다.
```

무언가를 import 해올 때, npm에서 설치된 패키지같은 경우에는 `from 패키지 이름`만 선언해줘도 되지만, 컴포넌트 같은 경우에는 import를 하려고 하는 파일의 상대 경로를 지정해서 불러와주어야 한다.

index.js에 search_bar.js를 렌더링 한다. index.js는 search_bar.js를 렌더링하고, 이 렌더링의 결과를 App 컴포넌트 안에 렌더링 한다. 이 App.js 컴포넌트는 div에 렌더링 할 것이고, 이 div는 index.js파일의 container라는 컨테이너 안에 위치한다.

리액트 컴포넌트의 형태

1. 함수형 컴포넌트
2. 클래스 컴포넌트

함수형 컴포넌트보다 클래스 컴포넌트가 더 많은 기능(상태라던지..)을 포함할 수 있다.

```js
// class component의 생성
// extends React.Component는 말 그대로
// 리액트 컴포넌트로부터 모든 기능을 제공받으라는 것이다
class SearchBar extends React.Component {}
```

함수형 컴포넌트로 시작할 지, 클래스형 컴포넌트로 시작할 지에 대한 고민은 무척 어렵다...

## Detecting handling events

`<input />` 안에:
`onChange`: 모든 HTML 인풋 요소에 change event가 발생하면 `onChange={함수}` 함수가 실행된다. 여기서 `onChange`는 prop이고 이 안에 함수를 쓰게 된다.

이벤트 핸들러 안에 들어갈 요소로써 이벤트 객체가 있는데 이는 e 또는 event라 정의할 수 있고, 어떠한 이벤트가 발생했는지를 알기 위해서는 `event.target.value` 등의 선언을 통해 입력이 되고있는 input 등을 바로 확인할 수 있다.

핸들러를 정의해줄 수도 있으나, 바로 적용시킬 수도 있다.

```js
// input 컴포넌트 내에 바로 적용시킨 것
class SearchBar extends Component {
  render() {
    return <input onChange={e => console.log(e.target.value)} />;
  }
}
```

## 상태 관리

함수형 컴포넌트는 상태를 가질 수 없고, 오직 클래스형 컴포넌트만 상태를 가질 수 있다.

```js
constructor(props) {
    super(props);

    this.state = {
      term: ""
    };
  }
```

위는 React component에서 상태를 정의하고 싶을 때 만드는 contructor이다.
Component가 constructor 함수를 가질 때:

- 부모 클래스에 메소드를 미리 정의했을 때 => component:
  - super를 호출하면서 이 부모 클래스의 메소드를 호출할 수 있다.

<!-- 챕터 18부터 다시 시작 -->

2019년 1월 14일

필요에 의해 Redux 부분부터 듣기로 했다. 챕터 34부터 시작.

## 리덕스

### 리덕스는 왜 필요하고, 우리가 사용하면서 얻는 이점이 무엇일까?

리덕스는 앱을 표현할 수 있는 모든 데이터를 가지고 있는 컨테이너라고 볼 수 있다. 리액트는 이런 데이터를 뷰로 변환하여 보여주는 역할을 담당한다고 보면 된다.

리덕스는 이 모든 데이터를 한 객체(상태 또는 state)로 집중시킨다.

만약, 간단한 카운터(+, -와 현재 카운트를 보여주는)가 존재한다고 할 때, 이를 데이터를 담고 있는 컨테이너와 뷰를 담고 있는 컨테이너로 나눈다고 가정해보자. 그렇게 되면 데이터를 담고 있는 컨테이너에는 카운터의 현 상태를 담고 있는 current count라는 데이터가 들어있을 것이고, 뷰를 포함하는 컨테이너에는 current count를 보여주고, number change를 보여주는 뷰들이 포함되어 있을 것이다. 이 두 컨테이너들이 합쳐지면 사용 가능한 앱이 되는 것이다.

리덕스는 앱의 상태를 담고 있거나, 어떠한 데이터를 뷰에 그릴지에 관한 정보를 담고 있다.

---

리액트는 뷰를 컨트롤하고, 리덕스는 데이터를 컨트롤한다고 보면 쉽다.

틴더라는 앱을 예로 들어서 리덕스와 리액트의 역할 분담을 이해해보자.

**데이터를 담고 있는 컨테이너**

- 사용자들(사용자의 이미지와 채팅 기록을 포함)
- 대화를 하고 있는 현재 사용자들 목록
- 지금 현재 보이고 있는 대화의 내용
- 리뷰가 되어야 하는 사용자들 목록(아직 다른 사용자들에게 보여지지 않음)
- 사용자들이 현재 보고 있는 이미지의 데이터

**뷰를 담고 있는 컨테이너**

- 이미지 카드
- 좋아요, 싫어요 버튼
- 대화 목록들
- 텍스트 아이템들(개인 메시지들)
- 텍스트 리스트(채팅 메세지들의 목록)

애플리케이션의 상태, 즉 자바스크립트의 한 객체에 애플리케이션이 필요한 모든 데이터와 관련된 상태들이 담겨있다고 보면 된다.

---

### 리듀서

리듀서는 하나의 애플리케이션 상태를 반환하는 함수이다. 리덕스는 여러가지의 상태를 가질 수 있고, 이에 따라서 여러 종류의 리듀서가 생길 수 있다.

책을 보여주는 앱이 있다고 가정하자.

**데이터를 포함하고 있는 컨테이너(리덕스)**

- 책 리스트
- 현재 선택된 책

**뷰를 포함하고 있는 컨테이너(리액트)**

- 책 리스트를 보여주는 뷰
- 리스트가 포함하고 있는 아이템을 보여주는 뷰
- 아이템의 상세 정보에 관한 뷰

책 리스트와 현재 선택된 책에 관한 각각의 리듀서가 존재해야 하기 때문에 2개의 다른 리듀서들이 필요할 것이다.

```js
// Application State - Generated by reducers

{
  books: [ {title: 'Harry Potter'}, { title: 'JavaScript'}], // Book Reducer
  activeBook: { title: 'JavaScript: The Good Parts'}
} // ActiveBook reducer

```

이제 상태의 값을 생성하는 함수를 만들어 볼 것이다.

리듀서를 위한 파일을 생성한 후, 함수를 작성한 뒤에 그 함수를 export하자. 그렇게 되면, 다른 파일에서 이 리듀서가 작성된 파일을 import할 때(책의 리스트가 있는) 자동적으로 책의 리스트가 담겨있는 리듀서를 불러올 것이다.

그렇기 때문에 이것을 두 개의 작업으로 볼 수 있다.

1. 리듀서를 만드는 작업
2. 이 리듀서를 다른 파일들에 연결해주는 작업

이 리듀서를 리듀서 폴더 안에 있는 index.js(combineReducers라는 함수가 정의 된 곳)에 import 해야 한다.

<!-- 1월 19일 챕터 40 -->

## 챕터 40

리덕스와 직접적인 연결이 없다면 이것은 view(dumb) component이다.

인강의 예제에서 왜 book-list를 container로 만들지에 대한 과정을 알아보자.

예제 내의 app.js가 모든 상태를 가지고 가장 최상위에 위치하지 않겠냐는 질문을 던질 수가 있는데, app.js는 사실 book list에 대해 신경을 쓰지 않는다고 볼 수 있다. book-list가 book list에 대해 신경을 쓰는 것이다. 그리고 active book에 관한 것도 book-detail이 신경을 쓰는 것이다.

app.js는 책의 리스트나 어떤 책이 선택되었는 지에 대한 것은 신경쓰지 않고,
여러 다른 페이지를 렌더해달라는 것이 전부이다. 그렇기 때문에 BookList와 BookDetail이 redux와 직접 연결되는 smart container가 될 것이다. app.js는 dumb component의 역할을 하는 것이다.

그렇기 때문에 컨테이너(container component or smart component - 리덕스가 가진 상태에 직접적으로 접근할 수 있는 컴포넌트)를 생성할 때는 최상위 컴포넌트가 기능과 관련된 상태를 가지고 있어야(리덕스와 연결이 되어야 한다) 한다는 것이다. 자식 컴포넌트가 상태를 필요로 해도 그와 연결된 최상위 컴포넌트만 리덕스와 연결되어야 한다.

<!-- 챕터 42 -->

## 챕터 42

그 후 `mapStateToProps(state)`라는 state을 매개변수로 받는 함수를 작성해 준다. 이 함수를 작성하는 이유는 이 애플리케이션의 상태(책의 리스트를 담은 배열, 현재 선택된 책)를 매개변수로 받는다. 이 함수에서 반환되는 값은 BookList 내에 props로 보여질 것이다.

`import { connect } from 'react-redux'` 해준 후,
`export default connect(mapStateToProps)(BookList)`와 같은 방식으로 export 시킨다.

connect는 함수와(mapStateToProps) 컴포넌트(BookList)를 받아서 컨테이너를 생성한다. 이 컨테이너는 리덕스에 의해 관리되고 있는 상태를 인식하는 컨테이너이다.

mapStateToProps 내에서 반환되는 것은 this.props로 접근할 수 있다. 이 함수는 리액트와 리덕스를 이어주는 아주 중요한 역할을 한다. 이 예제의 경우에서는 books라는 키를 가지고 state.books라는 값을 가진 것을 반환한다. state.books는 reducer에서 정의되는 books를 사용하기 위해 저렇게 쓰여졌다.

connect를 사용해서 컨테이너를 생성하면,

1. 상태가 바뀌는 일이 발생한면 렌더가 다시 발생한다.
2. 상태가 바뀌는 일이 발생하면, mapStateToProps내에 선언된 객체는 컴포넌트에 props로 할당된다.

<!-- 챕터 43부터 진행해야 함. -->

## 챕터 43

챕터 43은 위의 내용을 다시 복습하는 구간.

리덕스는 상태(데이터를 저장하는 컨테이너)를 제공하고, 리액트는 뷰를 제공한다고 볼 수 있다. 앱의 상태는 리듀서 함수에 의해 생성된다. 여기서는 reducer_books.js를 생성하여 책에 관한 정보가 담긴 객체들이 있는 배열을 반환시켰다. 이 book 리듀서를 리듀서 폴대 안에 생성되어 있는 index.js(리듀서를 총괄하는 js 파일) 내의 combineReducer 내에 선언해준다. 이 리듀서 함수는 books라는 키를 가지고 BooksReducer(reducer_books.js로부터 오는)라는 값을 가진, 이 객체 안에 선언된 것을 이 애플리케이션의 전역 상태에 선언하게 된다.

그 이후에 books_list라는 컴포넌트를 생성한 뒤, 이 컴포넌트가 이 애플리케이션의 상태에 대해 인식해야한다는 것을 알고는 리덕스와 연결하기로 결정했다(컨테이너로 만들기로 결정함). 컨테이너(즉, 스마트 컴포넌트)로 만들기 위해서는 우선 connent를 임포트 하고, 그 뒤에 mapStateToProps 함수를 작성하고, export default connect를 이용해 리덕스와 연결한다.

book_list를 컨테이너로 만들기로 한 결정의 배경은 오직 이 컴포넌트만이 앱의 전역 상태에 있는 BookList에 대해 알아야하기 때문이다(app.js같은 경우에는 BookList를 알 필요가 없다).

<!-- 챕터 44 액션과 액션 생성자 -->

## 챕터 44

이 예제의 문제가 하나 있다. 그 문제는 book reducer는 항상 같은 배열만 반환한다는 것이다. 지금 이 상태는 100% static(정적)인 상황이다. 시간이 지나도 지금 상태로는 이 상태에 변화를 줄 수 없다. 나중에 선택된 책이 어떤 것인지를 표시하게 해주려면 결국 상태의 변화를 나타낼 수 밖에 없다. 그렇기 때문에 동적인 상태도 표현할 수 있도록 코드를 작성해야 한다. 이를 위해서 action과 action creator를 사용해서 구현한다.

**리덕스 action의 라이플 사이클**

리덕스 내에서는 대부분의 모든 상황에서 사용자가 직접적 혹은 간접적으로 이벤트를 발생시켰을 때 action이 작동한다. 버튼을 클릭하거나, 드랍다운 메뉴를 펼치거나 하는 것이 직접적인 이벤트 발생의 예라면, 간접적으로는 Ajax통신이 완료된다던지, 페이지의 로드가 완료된다던지가 될 수 있다. 이러한 행동들은 action creator를 선택적으로 호출할 수가 있다.

Action creator는 action을 반환하는 함수이다. 예를 들어, 사용자가 목록에서 책 하나를 클릭했을 때, action creator를 호출하게 되는 것이다. 그렇게 되면 action creator는 action을 반환하게 되는데, 이 action은 자동적으로 모든 리듀서들에게 전송이 된다. 리듀서들은 action의 종류에 따라 어떤 상태를 반환할 지 선택을 할 수가 있다. 만약에 여기서 상태를 반환하기로 한다면, 이 새로 반환된 상태는 애플리케이션의 상태에 넣어지게 되고, 이 상태의 추가 때문에 리액트가 다시 렌더링을 하게 된다.

Action은 객체 안에 타입을 포함하고 있다. 그리고 action을 설명할 수 있는 데이터도 포함할 수 있다.

리듀서에 action이 전송될 때, 그 안에서는 switch(action type) 선언문이 action이 어떤 타입을 가지고 있는지에 따라 실행된다.

그리고 만약 선택된 타입에 무엇을 반환할지 정해져 있다면, 그것을 반환하게 될 것이다. default 설정은 현재의 상태를 그대로 반환한다.

그리고 이 스위치 문에서 반환되는 값이 애플리케이션의 새로운 상태 값으로 재할당이 된다.

> all reducers processed the action and returned new state. New state has been assembled. notify containers of the changes to state. On noticification, containers will render with new props.

<!-- 1월 20일 -->

## 챕터 45

이제 책을 클릭했을 때, 선택된 책이 보이도록 구현하기 위해서 actions 폴더 내에 index.js에 이와 관련된 action을 작성할 것이다.

index.js 안에 selectBook이라는 book을 매개변수로 받는 함수를 작성하고 적용을 해야한다. 적용을 할 때, 이 함수를 book_list.js에 import하고 핸들러로 넘겨준다고 생각할 수도 있지만, 이 일은 그렇게 간단하지 않다.

선언된 action으로 인해 반환되는 것이 모든 리듀서들을 거치도록 구현을 해야한다. Action creator가 리덕스에 연결되도록 해주어야 한다는 것이다.

book_list.js를 connect 훅을 사용해서 리덕스와 연결시켰던 것 처럼, 여기에다가 다시 bind를 통해 action creator와 연결해 줄 것이다.

book_list.js로 돌아온 뒤, selectBook을 import 해주고, 그 다음에 bindActionCreators라는 훅을 redux로부터 import 한다.

그리고 mapStateToProps 다음에는 mapDispatchToProps 함수를 작성하는데, 이 함수의 역할은 selectBook이 호출되었을 때 반환되는 값이 모든 리듀서들을 거치도록 하는 역할을 하도록 만들어주는 함수이다.

mapDispatchToProps를 통해 반환되는 것들은 BookList container에 props로 전달될 것이다.

<!-- 챕터 46 -->

## 챕터 46

mapDispatchToProps를 통해 selectBook이 반환될 것이기 때문에 이것`(this.props.selectBook)`을 위에 `<li>`에 onClick 이벤트를 통해 사용할 수가 있다.

index.js(actions 폴더 내의)로 돌아와서 selectBook에 타입을 정의해주려고 한다. return{} 내에 타입은 'BOOK*SELECTED'를 값으로 정해주고, payload는 book으로 정해줄 수 있다. 타입은 항상 대문자로, 그리고 대부분은 string을 사용하며 단어 별로 `*`를 사용하여 나누어줄 수 있다.

<!-- 챕터 47 -->

## 챕터 47

이제 해야될 것은 active_book을 위한 리듀서를 작성하는 것이다.

리듀서는 state과 action을 매개변수로 받는다. 매개변수에 들어오는 state는 전역의 state가 아닌, 하나의 리듀서가 관련하는 state만 취급한다.

만약에 작성된 리듀서와 관련없는 state이 들어오게 되면, 그냥 default state을 반환하도록 작성해줘야 한다.

선택된 책을 보여주는 리듀서를 작성 시, 사용자가 아무 선택을 하지 않았을 시에 넘겨줄 default state이 필요하다. 리듀서는 undefined를 상태로 넘겨주지 않고 에러를 발생시키기 때문에 default state을 항상 설정해주어야 한다!

이 예제에서는, 매개변수 state에 null을 설정해준다. `state = null`(ES6에 추가된 기본값 설정법)을 해주면, state가 undefined가 반환되어도 이를 null로 반환해 줄 것이다.

리듀서 안에서 값을 변경하는 행위를 해서는 안된다. 항상 오염되지 않은 객체를 반환해야 한다.

## 리듀서 index.js에 ActiveBook을 import하고 combineReducers안에 선언해주자. 여기서, 키로 정의되는 객체가 바로 전역 상태의 키가 된다.

**argument vs parameter**

parameter(매개변수)는 함수에 어떠한 값이 넘어오는지를 뜻해주고 argument(인자)는 함수로 넘어오는 실제적인 값을 뜻한다!

---

<!-- 챕터 48 -->

## 챕터 48

이제 선택된 책을 보여주는 book detail view를 만들 것인데, 이를 결정하기 위해서는 컴포넌트(VC)를 만들 것인지 컨테이너(CC)를 만들 것인지 결정해야 한다. 여기서는 우리가 어떤 책들이 있는지 알고, 언제 변경이 되는지 알기 때문에 이 컴포넌트는 리덕스에 연결될 수 있도록 컨테이너로 승격되어야 한다!

결국, 위의 뜻은 app.js는 책의 리스트와 책의 자세한 사항(어떤 책이 선택되었는지)을 뷰로 보여주기만 할 것이기 때문에, 어떤 책이 선택되었는지는 book detail만 알고 있으면 된다. 그렇기 때문에 우리는 active_book 컴포넌트를 컨테이너로 만들 것이다.

book-list를 리덕스와 연결했던 것 처럼 똑같이 하면 된다.

<!-- 챕터 49 조건부 렌더링! -->

## 챕터 49

리듀서가 실행될 때, 어떤 일이 일어나는 지를 알아보자.

애플리케이션이 처음 실행될 때:

1. 액션이 들어온다. 타입이 뭔지는 모른다(이 예제에서는 앱이 켜졌을 때 책이 바로 선택되지 않기 때문에 어떠한 타입도 없다고 볼 수 있다).
2. 그렇기 때문에 일단 `return state`문이 실행된다.
3. default값에 null을 넣어주었기 때문에 active book의 상태는 null값이 될 것이다.
4. 그렇기에 book-detail 내에 작성한 this.props.book.title도 없는 것(`null`이니까)으로 간주 될 것이다. 이것이 에러를 발생시킨다.

위의 상황을 방지하기 위해서, book-detail 내의 렌더 메소드에서 체크를 하는 코드를 작성해 줄 수 있다.

<!-- 챕터 50 -->

## 챕터 50

기억하고 넘어가야 할 것

1. 리덕스는 애플리케이션의 상태를 관리하는 역할을 한다. 앱의 상태와 컴포넌트의 상태는 다르다! 이 둘은 완전 다르다. 이 앱의 상태는 리듀서들로 구성된다.

2. 리듀서 index 파일 안에 컨테이너의 상태를 담게 된다. 한 컨테이너의 모든 상태는 리듀서 index 파일 내에 선언된 이름으로 사용할 수 있다.

3. 리듀서는 애플리케이션의 상태를 바꾸는 역할을 한다. 액션이 dispatch되면 모든 리듀서들에 보내지면서 맞는 type이 있는지를 확인한다.

4. action creators는 action을 반환하는 매우 간단한 객체이다. 액션은 항상 타입이 있어야하고, payload가 필요하다. 관례적인 것이다.

<!-- 리덕스 중급과정 : 미들웨어 챕터 51부터 -->

## 챕터 51

무엇을 어떻게 계획해서 만들 것인가?

- 날씨 정보를 제공해주는 앱을 만들 것이다.
  1. 유저들은 서치바를 통해서 도시를 검색할 수 있다.
  2. 검색을 하면, API에 요청을 보내서 다음 5일간의 날씨 정보를 받아올 것이다.
  3. 유저들은 많은 도시 정보들을 한번에 확인할 수 있다.

리덕스가 모든 데이터 통신과 관련된 로직을 가져야하고, 리액트는 뷰와 관련된 역할만 해야한다.

<!-- 챕터 52 -->

## 챕터 52

## 컴포넌트 셋업

0. App

- 모든 하위의 컴포넌트를 렌더할 컴포넌트.

1. SearchBar 컴포넌트

- search input, search button을 포함한 상단에 위치할 컴포넌트
- 이곳에서 리덕스 액션이 발생할 것이다.(featching data)

2. ForecastList 컴포넌트

- 리스트와 리스트 아이템을 한 컴포넌트에 넣어서 보여줄 것 같다.

3. Chart 컴포넌트

- 차트에 관한 정보를 받아와서 여러개의 다른 정보를 표현하는 컴포넌트로, 재사용할 수 있도록 생성할 것.

## 컴포넌트가 컨테이너가 될 것인지, 컴포넌트가 될 것인지를 정하자

### SearchBar

- 유저가 입력하는 도시의 정보를 요청해야하기 때문에 컨테이너가 되어야 한다.

- SearchBar 내에 사용되는 input은 controlled field(input에 입력되는 내용을 리액트(VC) 컴포넌트 상태에서 관리)화 시켜서 사용할 것이다.

- 이벤트 핸들러 생성 시, this.setState과 같은 무언가를 가리키는 코드를 사용할 때에는 bind를 생성자 안에서 연결해야 하는 것을 잊지 말자!

- 유저가 엔터 혹은 submit 버튼을 눌렀을 때, 서버로부터 날씨 관련 데이터를 받아오는 로직이 필요하다.

<!-- 챕터 56, 미들웨어 -->

## 챕터 56

## 미들웨어는 무엇인가?

미들웨어는 액션을 받은 함수들이다. (기본적으로) 액션의 타입과 payload에 따라 미들웨어는 이것들을 통과시켜줄 수도 있고, 아니면 콘솔 로그를 찍어보거나 아예 작동을 멈추게 할 수도 있다. 리듀서에 액션이 닿기 전에 원하는 동작을 추가한 다음에 리듀서로 넘겨주는 것이라고 볼 수 있다.

결국 미들웨어는 액션이 리듀서로 가기 전에 검사를 하고, 액션들이 통과할 수가 있는지 아니면 추가되야 하는 작업이 있는지 등을 확인한다.

미들웨어를 사용하기 위해, npm을 통해 redux-promise를 설치했다!

<!-- 챕터 57, Axios로 Ajax 리퀘스트 -->

## 챕터 57

이번 섹션에는 일단 리퀘스트를 보내는 것에 집중한다.

애플리케이션의 상태는 오직 리듀서와 액션들을 통해서 바꾸기 때문에, 날씨 정보를 불러오거나 애플리케이션의 상태를 바꾸기 위해서는(날씨 정보를 업데이트 하거나 추가하는 등의) 액션을 dispatch(액션 크리에이터를 부르기) 하고 Ajax 리퀘스트를 해야한다.

액션 크리에이터들은 항상 타입을 가지고 있는 액션이라는 객체를 반환해야 한다.

지난 번에는 type에 직접 문자열 값을 `'FETCH_WEATHER'` 이런 식으로 명해줬었는데, 이제는 `export const FETCH_WEATHER = 'FETCH_WEATHER'`과 같은 식으로 변수로 선언해주고 그것을 export하여 다른 곳에서도 사용될 수 있도록 해줄 것이다.

그럼 왜 이런 것(전역에서 사용할 수 있도록 변수를 선언해주고 export하는)을 하는 것일까?

- 액션 크리에이터와 리듀서 사이에서 액션 타입을 항상 일정하게 해주려고 하기 위함이다.
- 혹시 누군가가 action에 오타를 내어서 잘못 값을 입력하게 되는 등의 일을 방지하기 위함이다.
- 그리고 나중에 그 변수의 값을 수정함에 있어서도 매우 간편하다. 문자열 값으로 type일 지정해 주었다면, 액션과 리듀서에서 모두 똑같게 수정을 해주어야 할 텐데, 변수로 정해놓고 사용하면 그 변수의 값만 설정을 바꿔주면 여전히 같은 변수명으로 사용되고 있을 것이니까 말이다.

payload는 전에도 설명했듯이, action과 관련된 정보를 포함할 수 있는데, 여기다가 axios request를 get한 정보를 같이 담으면 될 것이다.

```js
import axios from "axios";

const API_KEY = "04e35625f77ea2b0f4bcd776054f8a9e";

const ROOT_URL = `http://api.openweathermap.org/data/2.5/forecast?q=London,us&appid=${API_KEY}`;

export const FETCH_WEATHER = "FETCH_WEATHER";

export function fetchWeather(city) {
  const url = `${ROOT_URL}&q=${city},us`;
  const request = axios.get(url);

  return {
    type: FETCH_WEATHER,
    payload: request
  };
}
```

<!-- 챕터 58 -->

## 챕터 58

이제 SearchBar를 redux와 연결해서 사용자가 도시를 검색창에 입력했을 때 action을 보내주는 코드를 작성해야 한다.

그러기 위해서는 필요한 hook들을 import한 뒤에, 코드 마지막에 mapDispatchToProps 함수를 작성해야 한다.

```js
function mpaDispatchToProps(dispatch) {
  return bindActionCreators({ fetchWeather }, dispatch);
}

// SearchBar를 export default하는 것을 지우고 이 밑에 선언한다.

export default connect(
  null,
  mpaDispatchToProps
)(SearchBar);

// null을 선언해주는 이유는 mapDispatchToProps는 항상 2번째 argument로 넘겨져야 하기 때문이다.
```

`onFormSubmit`을 bind 해주는 것을 잊으면 안된다!

<!-- 챕터 59 -->

## 챕터 59

reducer_weather.js 파일을 리듀서 폴더 내에 생성해주고, 이를 폴더 내의 index.js에 import 하자. 그 후, weather reducer를 combineReducers 내에 선언하자.

axios는 promise를 반환하는데, action creator에서는 payload가 이 request에 대한 promise를 반환하는 곳이 된다.

redux promise는 미들웨어로의 역할을 하면서 payload property를 확인해보면서, 이 payload에 promise가 들어오면 모든 action을 멈추고 (request가 끝나고 나면) promise를 분석한 결과를 리듀서로 변환하여 보내는 것이다.

<!-- 챕터 60 -->

## 챕터 60

이전 챕터에서 redux-promise가 알아서 promise를 분석해서 데이터를 넘겨주기 때문에, 우리는 이 데이터와 관련된 작업만 진행해주면 된다. 우리가 정작 필요한 데이터는 action.payload.data로 넘어오는 자료들이기에, 이 데이터만 저장하여 사용하면 된다.

우리는 도시의 정보를 배열안에 넣는 것이 좋을 것이다. 그래서 reducer_weather.js의 초기 state 값을 null로 설정했던 것을 `[]`로 해주자.

```js
import { FETCH_WEATHER } from "../actions/index";

export default function(state = [], action) {
  switch (action.type) {
    case FETCH_WEATHER:
      return [action.payload.data];
  }
  return state;
}
```

위와 같이 코드 작성을 해주면, 이제 유저들이 새로운 검색을 시도할 때마다 그 특정한 도시에 정보만 배열 안에 넣게 만드는 구조임을 알 수 있다. 그렇기 때문에, 새로운 정보만 그 때 다시 넣는 것이 아니라 이미 검색된(저장된) 정보에다가 새로 검색되는 도시의 정보도 추가시키는 방식으로 코드 작성을 해주어야 한다.

배열에 새로운 정보를 추가하고 싶다고 해서, `state = 'something'`이나 기존값을 mutate(기존의 것에서 뻗어나오는 것이 아닌)해서 복사하면 안되고, setState을 이용하거나 완전히 새로운 것을 만들어야 한다.

이 경우에는 새로운 정보를 추가할 때마다 완전히 새로운 배열을(기존의 정보 + 새로 담길 정보) 생성해주는 것이 옳은 방법이다. `concat`을 이용해서 새로운 정보를 추가시킬 수 있다. `concat`은 기존에 있는 배열에 이어 붙이지 않고 매번 새로운 배열을 생성한다.

```js
// 이렇게 새로운 배열을 생성하며 기존의 데이터에 새로운 데이터를 추가할 수 있다
state.concat([action.payload.data]);

// ES6 syntax를 이용하면...
[action.payload.data, ...state];

// 이와 같이 표현해 줄 수도 있다 ->
// 새로운 배열을 만들어서 action.payload.data를 추가하고 그 안에 이미 존재하고 있던 모든 데이터(...state)도 그대로 추가하라는 뜻의 분해대입이다
```

<!-- 챕터 61 -->

## 챕터 61

도시의 리스트를 불러서 보여줄 수 있는 컴포넌트를 만들 것이다. 이를 컴포넌트로 구성할 것인지, 컨테이너로 구성할 것인지를 생각해보자. 정보를 리덕스에서 받아와야하기 때문에, 이와 관련된 컴포넌트는 컨테이너가 되어야 한다.

`weather_list.js` 내에 필요한 마크업을 작성 한 뒤, 이를 리덕스와 연결시켜줘야 한다.

```js
function mapStateToProps(state) {
  return {
    // 리듀서 index.js에 작성한 weather를 가져다 쓰기 때문에 state.weather
    weather: state.weather
  };
}
```

위와 같이 작성한 것을 ES6 syntax를 사용하여 코드를 간결하게 할 수 있다.

```js
function mapStateToProps({ weather }) {
  return {
    weather: weather
  };
}
```

저기서 더 간결하게 하면,

```js
function mapStateToProps({ weather }) {
  return {
    weather // { weather } === { weather: weather}
  };
}
```

와 같이 작성할 수 있다!

<!-- 챕터 62 -->

## 챕터 62

weather(도시들의 날씨 정보를 담고 있다)라는 배열을 mapping하여 화면에 표시해주어야 한다.

```js
class WeatherList extends Component {
  renderWeather(cityData) {
    const name = cityData.city.name;
    return (
      <tr key={name}>
        <td>{name}</td>
      </tr>
    );
  }
  render() {
    return (
      <table className="table table-hover">
        <thead>
          <tr>
            <th>City</th>
            <th>Temperature</th>
            <th>Pressure</th>
            <th>Humidity</th>
          </tr>
        </thead>
        <tbody>{this.props.weather.map(this.renderWeather)}</tbody>
      </table>
    );
  }
}
```

위와 같이 이 인강에서는 renderWeather라는 함수를 만든 뒤, 그것을 `tbody` 안에 map 메소드를 사용하여 바로 함수를 넘겨주는 방식으로 표시하였다.

<!-- 챕터 64 -->

## 챕터 64

스파크라인이라는 라이브러리를 통해 그래프를 표시하기.

그래서 이 예제의 redux store 안에는...

```js
weather: [
  {
    city: { name: "city a" },
    list: [
      {
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 }
      }
    ]
  },
  {
    city: { name: "city b" },
    list: [
      {
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 },
        main: { temp: 260, humidity: 40, pressure: 55 }
      }
    ]
  }

  //  이것의 반복일 것
];
```

weather.map을 통해 각각의 도시들 정보를 표시할 것이다. 그리고 저 한 도시에 포함되어 있는 여러 온도와 습도 그리고 기압을 한 배열에 묶어야 할 것이다. 예를 들면, `temperature: [260, 260, 260, 260]`의 식으로 말이다(map을 사용하면 된다).

그래프는 Sparklines라는 라이브러리를 통해 작성하였다.

<!-- 챕터 65 -->

## 챕터 65

이제 위 챕터에서는 온도와 관련된 그래프를 그려주었는데, 이 똑같은 코드를 습도와 기압에도 사용해줄 것이기 때문에 재사용 가능한 컴포넌트를 만들어서 코드 중복을 줄여보자.

이 컴포넌트는 데이터를 props를 통해 받아올 것이기 때문에 리덕스와 연결할 필요가 없다. 그렇기에 컴포넌트로 작성하자(chart.js).

chart.js는 아무 상태를 가질 필요가 없기 때문에, 함수형 컴포넌트로 작성해줄 수 있겠다.

<!-- 챕터 66 -->

## 챕터 66

나머지 필요한 데이터도 똑같은 방식으로 맵핑한 다음에 chart.js를 통해 화면에 표시하자.

평균은 lodash라는 라이브러리를 사용해서 표시해보자.

<!-- 챕터 67 -->

## 챕터 67, 68

구글맵 적용과 약간의 CSS 변경 적용.

<!-- 프로젝트 리뷰 -->

## 리뷰

미들웨어(redux-promise)를 사용하여 데이터 타입에 따라 리듀서에 전해줄 정보를 자동적으로 감지하여 처리해주는 것.

mutating을 조심하자. 항상 새로운 값(배열)을 생성하여 사용하는 것으로 코드를 작성해야 한다.

분해대입 등의 활용.

스파크라인과 같은 라이브러리를 사용해서 프로젝트를 더욱 멋지게 꾸밀 수 있다.

<!-- 섹션 9 리덕스 + 리덕스 라우터 부터 -->

## 프로젝트의 구성 컴포넌트들

### index page: route `'/'`

블로그 포스트에 관한 목록을 보여주는 인덱스 페이지.

### show page: route `'/posts/5'`

어떤 포스트인지 보여주는 페이지.

### entering contents page: route `'/posts/new'`

글 작성을 할 수 있게 해주는 페이지.

---

<!-- 챕터 120 -->

## 챕터 120

이 프로젝트를 어떻게 설계할 것인지에 대해 알아보자.

유저가 페이지를 방문했을 때, 리덕스 라우터가 적용된 애플리케이션을 사용자들의 웹브라우저에 불러올 것이다. 이 첫 화면이 로드되었을 때, 우리는 사용자가 블로그 포스트들의 목록을 볼 수 있도록 해주고 싶다. 이때 블로그 포스트 API에 AJAX request를 보내서 그 목록들을 불러올 수 있다.

그리고 리액트 라우터를 사용해서 주소표시줄의 변경을 해줄 것이다. 리액트 라우터는 URL의 변경을 감지하여 그에 관련된 컴포넌트를 보여주는 방식으로 작동한다.

만약 유저가 URL 변경을 시도하면 History(리액트 라우터가 같이 설치한)에 변경점이 있다는 것을 알리고, History는 이와 관련한 parsing을 하고나서 리액트 라우터에 이 변경을 알린다. 이 변경점에 대해 리액트 라우터가 바뀐 URL에 관련된 상태 업데이트를 하게 되고, 그 후에 리액트에 어떠한 컴포넌트를 새로 그려야할 지를 다시 알려준다.

이러한 작동 방식은 옛날에 URL 변경 요청을 서버로부터 주고 받던 것이 아닌, 단 하나의 HTML 다큐먼트를 놓고 자바스크립트가 어떠한 컴포넌트를 그려야 하는지를 결정하게 한다.

<!-- 챕터 121 -->

## 챕터 121

`react-router-dom`으로부터 몇 가지의 기능을 import할 것이다. 먼저 `BrowserRouter`을 import할 것이다. 이 객체는 URL변경과 관련하여 history 조작하는 기능을 할 것이다. `Route`는 URL의 따라 어떤 컴포넌트를 보여줄 지를 결정하는 기능을 한다.

이 Route 기능을 이용해서 어떠한 URL 설정을 할건지, 이것을 이용하여 웹사이트의 구조를 어떻게 구성할 것인지를 정할 수 있다.

라우트(path name)의 이름과 컴포넌트의 이름은 같을 필요가 없다!

<!-- 챕터 122 -->

## 챕터 122

라우트 구조를 어떻게 설정할 것인가를 구상해보자.

홈 라우트는 `/`로 표기하는 것이 일반적이다.

이 예제의 구성은 첫 화면이 켜졌을 때 포스트의 리스트를 보여주는 `{PostsIndex}`라는 화면을 보여주고 싶을 것이기에, `/`와 연결되는 컴포넌트는 `{PostsIndex}`가 될 것이다.

그 다음은 포스트 하나를 선택해서 그의 세부적인 내용을 보고싶을 때의 연결이다. 이와 관련된 라우트는 `/posts/5`라고 정해줄 수 있다. 하지만 여기에 있는 '5'는 포스트의 id일 텐데, 이를 `/:id`(와일드카드) 이런 식으로 정해주어서 유저가 선택한 포스트의 아이디를 라우트 마지막에 오는 번호로 정하면 될 것이다. 이와 연결될 컴포넌트는 `{PostsShow}` 정도가 될 수 있겠다.

마지막으로는 새로운 글을 작성할 때의 라우트를 생각해 볼 수 있다. 새로운 글 작성을 유저가 누르면, 이를 위한 라우트는 `/posts/new`가 될 수 있겠고 이와 연결될 컴포넌트는 `{PostsNew}`를 연결해 줄 수 있겠다.

<!-- 챕터 123 -->

## 챕터 123

첫 화면을 작업해보자!

index.js에 PostsIndex 컴포넌트를 만들어서 Route에 연결해 줄 것이다. `/`와 관련된 path를 설정할 때는 신경을 써주지 않으면 원하지 않는 작동을 일으킬 수가 있다.

<!-- 챕터 124 -->

## 챕터 124

PostsIndex와 리덕스를 연결해주는 작업을 하고 넘어가자.

어떠한 구조의 데이터를 주고 받을 것인가에 관해 알고 있어야 한다.

생각해 볼 수 있는 데이터 전송들은:

1. posts와 관련된 데이터는: key -> posts, type은 array 그리고 이 배열안에 포스트와 관련된 객체가 들어있을 것이다.

2. activePost(사용자가 클릭하여 보고싶은 게시물)은 type은 object, 그리고 단 하나의 객체가 선택될 것이다(저 위 배열 안의 객체를 선택한 것이나 마찬가지이기 때문에).

여기서 변경을 할 수 있는 것이 있다.

URL이 바뀔 때, 상태가 변화될 것이고 이에 따라 화면이 다시 그려질 것이다. URL은 사용자가 선택한 포스트가 가진 고유한 id에 따라 바뀔 것인데, 그렇기 때문에 activePost에서 id값을 다시 불러올 필요가 없을 것이다. 이는 중복되는 데이터 전송이 일어나는 것이나 마찬가지기 때문에 activePost와 관련된 정보는 posts와 관련된 정보에도 이미 포함되어 있다. 그렇기에 우리는 사용자가 activePosts를 선택할 때는 URL에 담긴 id정보를 통해 상태 업데이트를 해줄 수 있을 것이다.

즉, URL이 선택되었을 때 1번 과정에서 받아온 포스트의 배열 정보 안에서 URL이 선택한 id와 일치하는 포스트를 찾아서 상태를 업데이트 해주면 되는 것이다.

또 한 가지 변경할 수 있는 점은, 1번 과정에서 배열 안에 들어있는 객체들을 객체 안에 들어있는 객체들로 변경해 줄 수 있을 것 같다. 배열 안에 있는 정보를 찾아야 할 때는 그 배열을 for문 등으로 접근해야 한다. 그렇기 때문에 하나의 객체 안에, key는 포스트의 id를 값으로 가지고 있고 value는 포스트가 가지고 있는 정보들을 포함시키고 있을 수 있겠다. 객체 내의 데이터에 접근하고 싶다면, `state.posts[postId]`와 같은 방식으로 접근하면 훨씬 코드 작성을 줄일 수 있기 때문이다.

이러한 방식의 리팩토링은 현업에서 많이 쓰이는 방식이다.

<!-- 챕터 125 -->

## 챕터 125

데이터 통신을 위해서 axios의 설치가 필요.

그 뒤에 index.js 파일 내에서 promise를 import한 뒤에 이를 미들웨어에 선언해주어야 한다.

이 챕터에서 일어나고 있는 일은 다음과 같다.

- axios 요청을 request라는 변수를 만들어서(root_url과 api_key를 포함한) 이를 action 안의 payload에 지정해준다.


<!-- 챕터 126 -->

## 챕터 126 

리듀서 폴더 내의 index.js를 작성하자. 더비 상태를 지우고, postsReducer를 선언 및 적용시킨 뒤에 posts_reducer.js를 생성하여 작성하자.

위에서 언급되었던, 배열로 된 정보를 객체화 시켜서 정보를 저장하고 사용하기 위해 lodash 라이브러리를 사용해서 저러한 변환 과정을 쉽게 할 것이다. 

즉, 이렇게 되어있는 구성을 객체로 바꾸고 싶은 것인데:
```js
const posts = [
  { id: 4, title: "Hi" },
  { id: 25, title: "bye" },
  { id: 36, title: "Hows it going" }
]

```

이를 lodash 라이브러리를 이용하면 쉽게 구현할 수 있다.

```js
_.mapKeys(posts, 'id')
// 이 코드는, 위의 배열로 되어있는 데이터 구성을 객체로 바꾸어줄 것이다. 

//  {"4":{"id":4,"title":"Hi"},"25":{"id":25,"title":"bye"},"36":{"id":36,"title":"Hows it going"}}

```

위와 같은 작업을 한 뒤에는, 찾고자하는 포스트를 매우 쉽게 찾을 수 있다.

```js

const state = _.mapKeys(posts, 'id')

state["4"]    // {"id":4,"title":"Hi"}
```

객체[key값] -> 객체 내의 키 값을 가지고 있는 value를 반환 

<!-- 챕터 127 -->

## 챕터 127 

actions 폴더 내에 FETCH_POSTS 파일을 작성했고, 이 액션을 리듀서에 연결했으므로 이제는 이것을 posts_index 컴포넌트에 연결해주어야 한다.

posts_index와 fetchPosts를 연결할 때, 이전과는 다른 방식으로 연결해줄 수 있겠다.
```js

export default connect(
  null,
  { fetchPosts: fetchPosts }
)(PostsIndex);

// ES6 syntax를 이용하여 그냥 fetchPosts만 적어줄 수도 있다.
```

이제 해야하는 작업은 posts_index가 랜딩될 때, 이 페이지와 관련된 정보를 바로 불러와서 사용자에게 보여주어야 하는 것이다.

componentDidMount를 이용해서 초기 렌더링이 된 후에 데이터를 불러오는 요청을 할 것인데, 왜 이 단계에서 데이터 요청을 보내는 것인가?
  - 이 데이터 요청을 보내는 것은 비동기(asyncronous)식 요청이기 때문이다. 리액트에서는 이러한 비동기식의 코드 작동을 관리하는 명령어가 없다. 

```js
componentDidMount() {
  this.props.fetchPosts()
}
```

<!-- 챕터 128 -->

## 챕터 128

애플리케이션 상태를 사용하고 싶으면, 그 컴포넌트 내에서 mapStateToProps 함수로 연결을 해주어야 한다!

`renderPosts()`라는 함수를 만들어서 this.props.posts 안에 들어있는 포스트들을 나열해줄 것인데, 이 데이터의 형태는 배열 안에 든 객체들이 아닌 객체 안의 객체 형태로 되어있다. 그래서 배열이였다면 배열의 map method를 사용해서 데이터를 보여줬을텐데, 이제는 lodash의 기능을 사용해서 객체 내의 객체들도 map method를 사용해서 표현할 수 있게 도와주는 기능을 사용할 것이다.

<!-- 챕터 129 -->

## 챕터 129

글쓰기 페이지의 구성을 위한 단계들:
  1. PostsNew 라는 새로운 컴포넌트의 생성 
  2. 라우트를 연결 
  3. Index와 New 사이의 네비게이션을 설정(Index와 New 사이의 링크를 연결해준다고 보면 된다)
  4. PostsNew에 글쓰기 관련 form의 구성 
  5. action creator를 생성해서 새로 작성된 글을 저장


2번 단계(route 설정을 해준 후) 후에 생길 수 있는 버그는 `/posts/new`로 이동했을 때, `/` URL을 가진 컴포넌트의 내용도 보인다는 점이다. 

<!-- 챕터 130 -->

## 챕터 130 

이전 챕터에서 2번 단계와 관련된 버그에 대한 이야기를 계속 이어나갈 것이다.

초기 화면에 대한 라우트 설정을 해주었을 때, 우리는 ` <Route path="/" component={PostsIndex} />` 이러한 구조의 라우트 컴포넌트를 생성하였다. 여기서 문제가 발생하는데, `/`가 포함된 모든 라우트 컴포넌트들은 이 PostsIndex가 가지고 있는 내용을 포함해서 렌더링을 하게 될 것이다. 리액트 라우터를 사용할 때 생기는 기대하지 못한 작동이기 때문에 이에 관한 특별한 설정을 해주어야 한다. 

이 문제를 해결하기 위해서, Switch 컴포넌트를 hook에 추가해주자. 

```js
 <Switch>
    <Route path="/" component={PostsIndex} />
    <Route path="/posts/new" component={PostsNew} />
 </Switch>
```

위와 같이 스위치 컴포넌트로 라우트 컴포넌트들을 감싸준 뒤에 특정한 path가 지정된 라우트 컴포넌트를 맨 위로 위치시켜야 한다. 

```js
 <Switch>
    <Route path="/posts/new" component={PostsNew} />
    <Route path="/" component={PostsIndex} />
 </Switch>
```

**그렇다면 route에 exact를 써주는 것과 switch를 사용하는 것의 차이는 무엇일까?**
  - [스택오버플로우 질문과 답](https://stackoverflow.com/questions/51961135/react-router-switch-and-exact-path)

<!-- 챕터 131 -->

## 챕터 131 

전통적인 웹사이트에서는 페이지 간의 이동을 위해서는 `<a>`를 사용했는데, 리액트 라우터를 사용하게 되면 `<Link>` 컴포넌트를 사용할 것이다. 

<!-- 챕터 132 -->

## 챕터 132 

글쓰기와 관련된 form 작성을 해줄 때에는 일반적인 방법에서 벗어나 redux-form을 사용해서 작성을 할 것이다. 

<!-- 챕터 133, 2월 1일 -->

## 챕터 133 

### Redux Form

리덕스 폼은 폼 내에 존재하는 상태들의 변화를 관리해주는데, 이 작업은 크게 이러한 순서로 진행된다:
  1. 폼 안에 있는 각각의 다른 상태들을 감지한다.
  2. 각각의 상태다마 필드 컴포넌트를 생성한다.
  3. 사용자가 필드 내의 인풋 내용을 변경한다.
  4. 리덕스 폼이 자동적으로 이 변화들에 대해 작업을 한다. 
  5. 유저가 폼을 전송한다. 
  6. 이 폼 내의 인풋들이 유효한지를 검사하고 폼을 전송한다.

이 과정 사이에는 리덕스 폼이 폼을 컨트롤 한다고 보면 된다. 

이 과정을 위해서 Field라는 훅과 reduxForm이라는 함수를 redux-form으로부터 import 하면 된다. Import 뒤에는 reduxForm과 PostsNew 컴포넌트를 연결해주어야 한다. 리덕스를 사용할 때의 connect를 import해서 사용하는 것과 똑같다고 보면 된다.


```js
export default reduxForm({
  form: 'PostsNewForm'
})(PostsNew);
```

reduxForm에 첫 인수로 들어오는 객체는, 한 종류의 폼이 아닌 여러 다른 종류의 폼을 적용시킬 수 있게 해준다. `form:` 다음에 올 value로는 특수한, 그 폼을 직접적으로 설명할 수 있는 이름이 오는 것이 제일 적절하다.

redux form을 사용하여 폼 필드를 작성할 때는, 일반적인 form 태그를 사용해서 작성할 수 있겠다. 

```js
 <form>
  <Field
    name="title"    
    component={this.renderTitleField} 
    // Field가 함수를 실행시키길 것이기 때문에 ()와 같은 식으로 작성할 필요가 없다. 
    // 이 컴포넌트 prop은 어떠한 종류의 input이 들어올 것인가를 결정한다. 
  />
</form>
```

우리가 만들 폼에는 타이틀, 카테고리, 콘텐츠라는 세 개의 다른 인풋들이 있을 것이기 때문에 3개의 Field 컴포넌트가 필요할 것이다. 

그럼 저 component prop에 넘겨줄 input과 관련된 JSX를 작성하여 보자. 

```js
renderTitleField(field) {
    return (
      <div>
        <input {...field.input} />
      </div>
    );
  }
  // {...field.input} 은 온갖 종류의 이벤트 핸들러를 한번에 불러오게 해준다. 
```

<!-- 챕터 135 -->

## 챕터 135 

```js
renderTitleField(field) {
    return (
      <div className="form-group">
        <label>Title</label>
        <input className="form-control" type="text" {...field.input} />
      </div>
    );
  }

  renderTagsField(field) {
    
  }
```

위와 같이 코드 중복이 발생할 수 있는 여지가 많기 때문에 이를 줄일 수 있는 방법을 알아보자.

```js
// renderField로 이름을 바꾸고 재사용 가능하게 바꿔보자.

renderField(field) {
    return (
      <div className="form-group">
        <label>{field.label}</label>
        <input className="form-control" type="text" {...field.input} />
      </div>
    );
  }
```

위와 같이 작성한 뒤, `<Field>` 컴포넌트를 작성할 때,

```js
  <Field 
  label="Title"
  name="title" component={this.renderField}
   />

   <Field
  label="Tags"
  name="tags"
  component={this.renderField}
  />
```

<!-- 챕터 136 -->

## 챕터 136

이와 같이 label과 같은 props을 만들어 준 뒤 `renderField`내에서 `field.label`과 같이 사용할 수 있다.

그리고 form을 전송할 때 그 form이 유효한지 안한지를 검사하기 위해서 validate이라는 함수를 만들어 준 뒤, reduxForm helper에 추가해 줄 것이다. 

```js
export default reduxForm({
  validate,
  form: "PostsNewForm"
})(PostsNew);
```

validate 함수는 form의 라이프 사이클에 자동적으로 호출 될 것이다. 

```js
function validate(values) {
  // 인수로 받는 values에는 => { title: 'adf', categories: 'dfadf', content: 'adf1'}와 같은 식으로 정보가 들어있을 것.
  const errors = {};

  

  // validate the inputs from 'values'
  if (!values.title) {
    errors.title = "Enter a title!"
  }

  // 혹은 여러 조건을 걸어줄 수도 있다.

  if (!values.title || values.title.length < 3) {
    errors.title = "Enter a title that is at least 3 characters long"
  }

  if (!values.categories) {
    errors.categories = "Enter some categories"
  }

  if (!values.content) {
    errors.content = "Enter some content please"
  }
  // of errors is empty, the form is fine to sumbit 
  // if errors has *any* properties, redux form assumes form is invalid 

  return errors

}
```

이 validate 함수는, `errors={}`가 비어있다면 아무 문제없이 지나가고, 만약 에러가 발생해서 errors 안에 무엇이 추가되어 있다면 그와 관련된 것을 return하게 해주는 함수이다. 여기에 작성된 `values.title`는 input 태그 내의 name 프로퍼티와 연걸되므로 그 둘의 이름은 같아야만 한다.  

<!-- 챕터 137 -->

## 챕터 137 

이제 이 에러 메세지를 input 박스 밑에 출력하도록 설정하자. 

```js

 renderField(field) {
    return (
      <div className="form-group">
        <label>{field.label}</label>
        <input className="form-control" type="text" {...field.input} />
        
        {field.meta.error}
      </div>
      
    );
  }
```

`{field.meta.error}`를 input 밑에 작성하자. 이렇게 되면, redux form이 렌더될 때 validate 함수를 실행시키고 에러가 존재한다면, 이 에러 메세지를 `{field.meta.error}`내에 보여주게 될 것이다. 


<!-- 챕터 138 -->

## 챕터 138 

reduxForm으로 PostsNew 컴포넌트를 연결해주었을 때, 이 reduxForm은 많은 properties를 추가해준다. 

```js
render() {
    const { handleSubmit } = this.props
    return (
      <form onSubmit={handleSubmit(this.onSubmit.bind(this))}>
        <Field

      // ...
```

여기서 handleSubmit을 props로 받아올 수 있는 이유 중 하나도, 이 handleSubmit이 reduxForm에서 제공해주는 많은 property 중 하나이기 때문이다. 

```js
 <form onSubmit={handleSubmit(this.onSubmit.bind(this))}>
 ```

이 handleSubmit은 리덕스 쪽에서 validation과 관련된 작업을 해주기 위한 것이라 볼 수 있고 그 유효성 검사가 끝나면 handleSubmit() 안에 있는(인수로 있는) 프론트엔드 쪽에서 작성하는 onSubmit 핸들러가 실행 될 것이다. 그리고 여기서 bind(this)가 가르키는 것은 이 컴포넌트라고 볼 수 있다. 

<!-- 챕터 139 -->

## 챕터 139

이제 다시 validation에 관련된 작업을 진행하자. 

지금 우리가 가진 validation의 문제는 사용자가 입력하기도 전에 에러메세지가 보인다는 것이다. 우리가 원하는 작동은 input에서 포커스가 없어졌을 때(유저가 다른 input으로 이동했을 때) 조건이 맞지 않는다면 그 에러메세지를 보여주기 원하는 것이다. 

리덕스에서는 이와 관련한 작동을 위해 3가지의 단계를 거치게 된다. 

이 3가지 단계는 pristine -> touched -> invalid 단계로 볼 수 있다.

1. pristine
  - 이 단계는 default 상태의 input(맨 처음 화면이 그려졌을 때) 상태이다. 
  - 어떠한 input도 유저에 의해 건드려지지 않았거나 선택 자체도 된 적이 없는 상태를 뜻한다. 

2. touched
  - 이 단계는 유저가 선택 혹은 포커스를 한 뒤에 다른 input으로 이동을 한 경우이다. 
  - 이 단계는 유저가 어떠한 작업을 한 뒤, 그 작업을 완료한 뒤 다른 필드로 넘어간 것으로 본다. 

3. invalid
  - 이것은 유효성 검사를 하는 단계로, 우리는 이 단계의 활성화가 유저들이 input에 어떠한 작업을 한 다음에 작동하기를 원한다. 

3번의 작동을 위해서, 우리가 지금 단순히 `{field.meta.error}`라고 작성했던 코드를 삼항연산자를 통해 조건을 생성할 것이다. 

```js
// 만약 touched 되었다면 에러 메세지를 보여주고(에러가 있을 경우)
// touched가 되지 않은 상황이라면 빈 문자열을 보여준다. 
  {field.meta.touched ? field.meta.error : ""}
```

여기서 쓰이는 meta.touched도 리덕스 폼에서 제공하는 것으로, 유저가 input과 관련된 행동을 취하였는 지를 확인해준다. 

<!-- 챕터 140 -->

## 챕터 140 

위에 작성했던 코드에 input에 아무것도 입력이 안되었을 시에 빨간 테두리와 빨간 에러 메세지를 보여주는 코드를 작성하고, 코드의 길이를 분해대입을 통해서 줄여보자.

```js
  renderField(field) {
    const {
      meta: { touched, error }
    } = field;
    const className = `form-group ${touched && error ? "has-danger" : ""}`;

    return (
      <div className={className}>
        <label>{field.label}</label>
        <input className="form-control" type="text" {...field.input} />
        <div className="text-help">{touched ? error : ""}</div>
      </div>
    );
  }
```

<!-- 챕터 141 -->

## 챕터 141 

캔슬 버튼을 링크 태그를 이용해서 적용시키자. 

<!-- 챕터 142 -->

## 챕터 142 

이제 전송 버튼을 눌렀을 때, 서버로 보내고 싶은 정보를 담아서 보낼 수 있게 설정하자. 

actions 폴더 내의 index.js로 이동해서:

```js
export const CREATE_POST = "create_post";

// ...

export function createPost(values) {
  const request = axios.post(`${ROOT_URL}/posts${API_KEY}`, values);

  return {
    type: CREATE_POST,
    payload: request
  };
}

```

이와 같이 작성을 해준다. 이 후에 리듀서 폴더 내로 이동해서 CREATE_POST라는 타입을 리듀서가 확인했을 때, 어떠한 작동을 하도록 할 것인가에 대한 정의를 해주어야 한다. 

일단은 posts_new.js에도 액션 크리에이터를 연결해주어야 하는데, 일단 `{connet}`와 actions 폴더 내의 index.js에 정의했던 createPost를 import 해주고 난 뒤에:

```js
export default reduxForm({
  validate,
  form: "PostsNewForm"
})(connect(null, { createPost })(PostsNew));
```

이와 같이 `(PostsNew)` 괄호가 쳐져있는 곳 안에다가 connect를 사용해서 연결해 줄 수 있다.

그리고 난 뒤에 onSubmit 버튼 내의 코드는:

```js
 onSubmit(values) {
    this.props.createPost(values);
  }
```

로 작성해주자.

<!-- 챕터 143 -->

## 챕터 143 

이제 포스트 작성이 완료된 후에는 포스트 리스트로 돌아가도록 설정을 해주자. 한 가지의 조건이 있는데, 오직 API 리퀘스트가 성공이 되었을 때만 유저를 포스트 리스트로 이동시켜주는 것이다. 

리퀘스트가 성공한 뒤에 redirect를 시켜주어야 혹시나 모를 경우들(redirect되버리고 나서 post request가 성공한다던지)에 대해 대비할 수 있다. 

```js
 onSubmit(values) {
    this.props.createPost(values, () => {
      this.props.history.push("/");
    });
  }
```

위와 같은 구현을 위해서 values 다음에 callback으로 `this.props.history.push('/')`를 작성해주자. 그리고 actions 폴더 내의 index.js에 있는 createPost에도 밑과 같이 작성해주자.

```js
export function createPost(values, callback) {
  const request = axios
    .post(`${ROOT_URL}/posts${API_KEY}`, values)
    .then(() => callback());

  return {
    type: CREATE_POST,
    payload: request
  };
}
```

values 다음 인수로 callback을 추가해주고, request가 선언된 곳에 `.then`을 사용해서 post 리퀘스트가 성공했을 시에 callback 함수를 실행시키도록 구현해주자.

<!-- 챕터 144 -->

## 챕터 144 

이제는 포스트의 디테일을 보여주는 컴포넌트를 작성할 것이다.

PostsShow라는 컴포넌트를 만든 뒤, 이를 Route에 추가해야 한다. Route를 선언하는 순서가 중요하기 때문에 이미 작성된 Route들 사이에 이 컴포넌트를 선언하도록 하자. 

```js
 <Switch>
  <Route path="/posts/new" component={PostsNew} />
  <Route path="/posts/:id" component={PostsShow} />
  <Route path="/" component={PostsIndex} />
</Switch>
```

<!-- 챕터 145 -->

## 챕터 145

포스트를 불러와서 그것의 디테일을 보여주려면 두 가지의 상황을 생각해야 한다. 

첫 번째는 사용자가 PostsIndex 페이지에 먼저 접속하여 포스트의 리스트를 보게 되는 것과 두 번째로는 PostsShow를 직접적으로 먼저 방문하는 경우를 따져야 한다. 

여기서 강조되는 것은 사용자가 PostsShow를 URL로 직접 접속하였을 때, PostsShow의 역할은 다른 불필요한 정보를 불러오지 않고 그 유효한 포스트 하나만 불러와야 하는 역할을 가진다는 것이다. 유저가 항상 PostsIndex를 거친 뒤에 포스트를 직접 클릭할 것이라는 생각을 가지면 안된다.

```js
// actions 내의 index.js에 가서 하나의 포스트를 get해오는 함수를 작성하자.
// 위에 FETCH_POST = "fetch_post"의 작성도 꼭!

export function fetchPost(id) {
  const request = axios.get(`${ROOT_URL}/posts/${id}${API_KEY}`);

  return {
    type: FETCH_POST,
    payload: request
  };
}

```

위를 작성한 뒤에 reduers 폴더 내의 reducer_posts로 가서 case를 추가해주어야 한다.

```js
import _ from "lodash";

// index.js(actions 폴더 내의)에서 import해오는 것이기에 자세한 파일명까지 적어줄 필요는 없다.
import { FETCH_POSTS, FETCH_POST } from "../actions";

export default function(state = {}, action) {
  switch (action.type) {
    // FETCH_POST CASE
    // ES5 까지만 가능하다면 이렇게 풀어서 작성할 수 있음.
    case FETCH_POST:
      const post = action.payload.data;
      const newState = { ...state };
      newState[post.id] = post
      return newState

    case FETCH_POSTS:
      return _.mapKeys(action.payload.data, "id");
    default:
      return state;
  }
}

```

우리는 이때까지 저장했던 정보를 보존시키고 싶기 때문에 새로운 객체를 생성하는 방식으로 코드를 작성한 것이다. 하지만 ES6 문법을 사용할 경우에는 아래와 같이 줄여서 작성할 수 있다.

```js
return { ...state, [action.payload.data.id]: action.payload.data };
```

여기서 `[action.payload.data.id]: action.payload.data`이 뜻하는 것은 배열을 만들라는 뜻이 아닌, `action.payload.data.id`이 value를 이용하여 새로운 key를 만들고 `...state`(기존에 존재하던 포스트 정보)에 추가하라는 것이다. 그리고 그것의 value를 `action.payload.data`로 설정해주라는 것이다. 

<!-- 챕터 146 -->

## 챕터 146

이제 posts_show.js에 리덕스를 연결시켜야 한다. 

```js
import React, { Component } from "react";
import { connect } from "react-redux";
import { fetchPost } from "../actions";

class PostsShow extends Component {
  render() {
    return <div>Posts Show!</div>;
  }
}

export default connect(
  null,
  { fetchPost }
)(PostsShow);

```

일단은 이와 같이 연결을 시킨 뒤에, 언제 action creator를 호출시킬 것인지를 정해야 한다. componentDidMount 내에서 액션 크리에이터를 호출시키는 것이 옳다.

그리고 특정한 id를 받아와서 이용해야 유저가 어떤 포스트를 선택했을 때, 그 포스트의 정보만 불러올 수 있기 때문에 `this.props.match.params.id`를 사용해서 id의 정보를 받아와야 한다. `match.params`는 `:id`와 같이 url내에 속한 와일드카드 토큰들의 정보를 받아올 수 있다.

```js
// 이렇게 작성할 수 있다
class PostsShow extends Component {
  componentDidMount() {
    const { id } = this.props.match.params;
    this.props.fetchPost(id);
  }
```

그 다음에 포스트를 렌더해주어야 하는데, 일단은 이렇게 생각해 볼 수도 있다. 포스트 리스트를 다 불러온 뒤에 그 중 유저가 선택한 특정한 포스트를 렌더하도록 말이다.

```js
 render() {
    posts[this.props.match.params.id] // the post we want to show
    return <div>Posts Show!</div>;
  }
}

function mapStateToProps({ posts }) {
  return { posts }
}
```

하지만 이렇게 되면, 항상 포스트를 새로 그려줄 때마다 포스트 리스트를 불러와야 한다는 단점이 있다. 우리는 포스트 하나가 필요하기 때문에 다른 방식으로 작성하는 것이 효율성이나 비용면에서 훨씬 나은 동작을 할 것이다. 

```js
function mapStateToProps({ posts }, ownProps) {
  
}
```

위의 코드에서 첫 번째 인수로 들어가는 것은 항상 애플리케이션의 상태가 되어야하고, 두 번째로 들어올 인수로는 관례로 불리는 `ownProps`가 된다. 이 `ownProps`는 PostsShow 컴포넌트에 전 해지는 props를 뜻한다. 이 뜻은 `this.props === ownProps`나 마찬가지인 것이다.

```js
// 이와 같이 작성할 수 있다.
function mapStateToProps({ posts }, ownProps) {
  return { posts: posts[ownProps.match.params.id] };
}
```

이렇게 해주는 이유는 무엇일까?
  - 이런 식으로 코드를 작성하게 되면, 이 프로젝트에서 처럼 별개의 포스트를 보여주는 PostsShow 같은 컴포넌트는 데이터의 의존도(포스트 하나를 보여주는데도 항상 포스트의 리스트를 다 불러와야 하는)를 낮출 수 있고 재사용이 더욱 가능한 컴포넌트가 된다. 
  - 그렇기 때문에 위와 같이 코드를 작성하는 이점이 있는 것이다. 


<!-- 챕터 147 -->

## 챕터 147 

이제 개별의 포스트를 렌더해보자.

```js
 render() {
    const { post } = this.props;
    return (
      <div>
        <h3>{post.title}</h3>
        <h6>Categories: {post.categories}</h6>
        <p>{post.content}</p>
      </div>
    );
  }
```

렌더 함수 내에 이 코드를 작성하고 실행을 하면...! 에러가 발생한다. title이 선언되지 않았다고! 그 이유는 무엇일까? 그 이유는 초기 렌더가 진행될 때, 우리는 componentDidMount가 실행된 뒤에 포스트의 정보를 받아오는데 초기 렌더 과정에서는 아직 아무 포스트의 정보가 들어있지 않기 때문이다.

```js
render() {
    const { post } = this.props;

    if (!post) {
      return <div>Loading...</div>;
    }

    return (
      <div>
        <h3>{post.title}</h3>
        <h6>Categories: {post.categories}</h6>
        <p>{post.content}</p>
      </div>
    );
  }
```

이와 같이 post에 아무것도 들어있지 않다면, loading이라는 텍스트를 보여주도록 코드를 작성할 수 있다. 

<!-- 챕터 148 -->

## 챕터 148

유저가 포스트를 선택하면 그 특정 포스트로 이동할 수 있도록 작성하자. 

```js
renderPosts() {
    return _.map(this.props.posts, post => {
      return (
        <li className="list-group-item" key={post.id}>
          <Link to={`/posts/${post.id}`}>{post.title}</Link>
        </li>
      );
    });
  }
```

이것은 간단하게 post.title에 link 태그를 감싸주어서 경로를 설정해주자.

이 다음에 발견된 문제는 index page가 로드될 때, 포스트의 모든 리스트를 한 번 리퀘스트하고 그 다음에 포스트 각각의 내용도 리퀘스트를 하는 불필요한 데이터 요청이 발생한다는 것이다. 작은 애플리케이션을 구상할 때에는 이것이 괜찮을 수 있지만, 네트워크의 사용량을 걱정해야하는 프로젝트라면 이와 같은 작업을 해줄 수 있다.

```js
// posts_show.js 내의 componentDidMount()에서 
// 포스트가 존재하지 않는다면,
// 포스트를 불러오자고 작성을 한다.

 if (!this.props.post) {
      const { id } = this.props.match.params;
      this.props.fetchPost(id);
    }
```

<!-- 챕터 149 -->

## 챕터 149 

유저가 선택한 포스트를 삭제할 수 있도록 하자.

```js
  onDeleteClick() {

    // 이러한 식의 id 식별은 위험할 수 있는데,
    // 백엔드에서 아직 post를 불러오지 않았을 수 있기 때문이다.
    this.props.deletePost(this.props.post.id);
  }
```

그렇기 때문에:

```js

onDeleteClick() {
    // params를 이용한 접근은 항상 id의 정보를 가지고 있을 것이기에 
    // 안전하다. 
    const {id} = this.props.match.params
    this.props.deletePost(id);
  }

```

이 뒤에 버튼을 작성하고 이벤트 핸들러를 넘겨주자.

```js
 <button
  className="btn btn-danger pull-xs-right"
  onClick={this.onDeleteClick.bind(this)}
>
  Delete Post
</button>
```

그리고 난 뒤에 액션 크리에이터에서 import 해오는 코드에 미리 작성을 하자: `import { fetchPost, deletePost } from "../actions";`

그리고 export 시에도 연결해주어야 한다. 

```js

export default connect(
  mapStateToProps,
  { fetchPost, deletePost }
)(PostsShow);
```

이렇게 먼저 설정을 한 뒤, 액션 크리에이터로 넘어가서 이와 관련된 delete 코드를 작성하자. 

```js
export function deletePost(id) {
  const request = axios.delete(`${ROOT_URL}/posts/${id}${API_KEY}`);

  return {
    type: DELETE_POST,
    // 다른 경우들처럼 리퀘스트를 반환받는게 아니라,
    // 그냥 삭제할 시의 id만 리턴받는 것이 좀 더 명확해보인다.
    // 리듀서에서는 페이로드에서 반환되는 id만 삭제하기 때문이다.
    payload: id
  };
}
```

하지만 그냥 삭제만 하는 것이 아니라, 삭제가 성공적으로 되었다면 인덱스 화면으로 넘어가는 코드를 작성해주자.

```js
// posts_show 내에서 

 onDeleteClick() {
    const { id } = this.props.match.params;

    this.props.deletePost(id, () => {
      this.props.history.push("/");
    });
  }
```

그리고 나서,

```js
export function deletePost(id, callback) {
  const request = axios
    .delete(`${ROOT_URL}/posts/${id}${API_KEY}`)
    .then(() => callback());

// ...

```

이제 삭제를 한 뒤에 메모리에 남아있는 삭제된 포스트들을 정리해주고 새로운 포스트를 반환해주어야 한다.

```js
import _ from "lodash";

// index.js(actions 폴더 내의)에서 import해오는 것이기에 자세한 파일명까지 적어줄 필요는 없다.
import { FETCH_POSTS, FETCH_POST, DELETE_POST } from "../actions";

export default function(state = {}, action) {
  switch (action.type) {
    case DELETE_POST:
      return _.omit(state, action.payload);
```

lodash를 이용해서 state object가 삭제하는 key(id)를 가지고 있다면, 그 key(아이디)를 삭제한 뒤 새로운 리스트를 반환하도록 해주는 명령이다. 

만약 객체가 아닌 배열로 구성된 목록이였다면, `return _.reject(state, post => post === action.payload)` 와 같이 작성했어야 할 것이다.


