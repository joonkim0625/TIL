# React: udemny online lecture

강의와 관련된 개발환경 설정

JSX : 부분적인 템플릿 혹은 변형된 자바스크립트로써, 자바스크립트 안에 HTML의 소스코드를 사용할 수 있게 해준다. 바벨과 같은 컴파일러를 통해서 바닐라 자바스크립트로 변환된 뒤에 화면에 표시된다.

React component를 화면에 그리기 위해서는:

1. React라는 라이브러리를 불러와야 하기 때문에 `import React from 'react';`를 해주는 것을 잊어서는 안된다.
2. 그리고 App.js(혹은 index.js)를 DOM에 붙인 뒤 화면에 그려주어야 하기 때문에 ReactDOM을 `'react-dom'`으로 부터 import를 해와야 한다.

DOM에 컴포넌트를 렌더하기 위해서는 컴포넌트를 인스턴스화 해야한다. 인스턴스화를 하기 위해서는 ReactDOM.render()안에 `<App />`이라는 인스턴스(App이라는 클래스가 아닌)를 렌더하라고 지정해주어야 한다.

인스턴스를 지정해주었다고 해서, 렌더가 되는 것이 아니다. 그 이유는 어디에다가 렌더를 해주어야 하는 지도 지정해주어야 하기 때문이다. 이는 index.html내에 있는 root를 찾아서 지정해주면 된다.

<!-- 섹션 1, 챕터 12 부터 시작 -->

# 2018-12-27

우리가 app을 만들 때, 어떻게 컴포넌트를 구성할 지 정해야 한다.

1. app 상단의 검색 바 컴포넌트

- 이는 검색하는 기능을 가지고 있고, 검색 바를 렌더링 할 것이다

2. app 중간에 비디오를 플레이하는 컴포넌트

- 역시 기능과 렌더링

3. 비디오의 프리뷰를 보여주는 컴포넌트

- 비디오의 프리뷰 썸네일과 타이틀을 포함

4. 3번의 비디오 프리뷰들을 포함하는 리스트를 보여주는 컴포넌트

5. 그리고 위의 4가지 모두를 포함할 하나의 전체 컴포넌트

파일 당 하나의 컴포넌트를 만들어야 한다.

## Youtube API를 사용해서 비디오 재생하는 컴포넌트의 생성

npm을 통해 youtube-api-search를 설치. 설치 시에 `--save`를 선언하면, 이는 package.json에 파일을 자동으로 저장해달라는 의미이다.

컴포넌트를 생성한 뒤에 export를 하지 않으면, 다른 컴포넌트에서 불러와 사용할 수가 없다. 그렇기 때문에 export를 하는 것을 잊지 말자!

```js
// 무언가를 export 할 때,

const SearchBar = () => {
  return <input />;
};

const foo = 5;

export default SearchBar;

// 위와 같은 선언은 foo는 제외한 SearchBar만 export 한다.
```

무언가를 import 해올 때, npm에서 설치된 패키지같은 경우에는 `from 패키지 이름`만 선언해줘도 되지만, 컴포넌트 같은 경우에는 import를 하려고 하는 파일의 상대 경로를 지정해서 불러와주어야 한다.

index.js에 search_bar.js를 렌더링 한다. index.js는 search_bar.js를 렌더링하고, 이 렌더링의 결과를 App 컴포넌트 안에 렌더링 한다. 이 App.js 컴포넌트는 div에 렌더링 할 것이고, 이 div는 index.js파일의 container라는 컨테이너 안에 위치한다.

리액트 컴포넌트의 형태

1. 함수형 컴포넌트
2. 클래스 컴포넌트

함수형 컴포넌트보다 클래스 컴포넌트가 더 많은 기능(상태라던지..)을 포함할 수 있다.

```js
// class component의 생성
// extends React.Component는 말 그대로
// 리액트 컴포넌트로부터 모든 기능을 제공받으라는 것이다
class SearchBar extends React.Component {}
```

함수형 컴포넌트로 시작할 지, 클래스형 컴포넌트로 시작할 지에 대한 고민은 무척 어렵다...

## Detecting handling events

`<input />` 안에:
`onChange`: 모든 HTML 인풋 요소에 change event가 발생하면 `onChange={함수}` 함수가 실행된다. 여기서 `onChange`는 prop이고 이 안에 함수를 쓰게 된다.

이벤트 핸들러 안에 들어갈 요소로써 이벤트 객체가 있는데 이는 e 또는 event라 정의할 수 있고, 어떠한 이벤트가 발생했는지를 알기 위해서는 `event.target.value` 등의 선언을 통해 입력이 되고있는 input 등을 바로 확인할 수 있다.

핸들러를 정의해줄 수도 있으나, 바로 적용시킬 수도 있다.

```js
// input 컴포넌트 내에 바로 적용시킨 것
class SearchBar extends Component {
  render() {
    return <input onChange={e => console.log(e.target.value)} />;
  }
}
```

## 상태 관리

함수형 컴포넌트는 상태를 가질 수 없고, 오직 클래스형 컴포넌트만 상태를 가질 수 있다.

```js
constructor(props) {
    super(props);

    this.state = {
      term: ""
    };
  }
```

위는 React component에서 상태를 정의하고 싶을 때 만드는 contructor이다.
Component가 constructor 함수를 가질 때:

- 부모 클래스에 메소드를 미리 정의했을 때 => component:
  - super를 호출하면서 이 부모 클래스의 메소드를 호출할 수 있다.

<!-- 챕터 18부터 다시 시작 -->
2019년 1월 14일

필요에 의해 Redux 부분부터 듣기로 했다. 챕터 34부터 시작.

## 리덕스 

### 리덕스는 왜 필요하고, 우리가 사용하면서 얻는 이점이 무엇일까?

리덕스는 앱을 표현할 수 있는 모든 데이터를 가지고 있는 컨테이너라고 볼 수 있다. 리액트는 이런 데이터를 뷰로 변환하여 보여주는 역할을 담당한다고 보면 된다. 

리덕스는 이 모든 데이터를 한 객체(상태 또는 state)로 집중시킨다. 

만약, 간단한 카운터(+, -와 현재 카운트를 보여주는)가 존재한다고 할 때, 이를 데이터를 담고 있는 컨테이너와 뷰를 담고 있는 컨테이너로 나눈다고 가정해보자. 그렇게 되면 데이터를 담고 있는 컨테이너에는 카운터의 현 상태를 담고 있는 current count라는 데이터가 들어있을 것이고, 뷰를 포함하는 컨테이너에는 current count를 보여주고, number change를 보여주는 뷰들이 포함되어 있을 것이다. 이 두 컨테이너들이 합쳐지면 사용 가능한 앱이 되는 것이다. 

리덕스는 앱의 상태를 담고 있거나, 어떠한 데이터를 뷰에 그릴지에 관한 정보를 담고 있다. 

---

리액트는 뷰를 컨트롤하고, 리덕스는 데이터를 컨트롤한다고 보면 쉽다. 

틴더라는 앱을 예로 들어서 리덕스와 리액트의 역할 분담을 이해해보자. 

**데이터를 담고 있는 컨테이너**
  - 사용자들(사용자의 이미지와 채팅 기록을 포함)
  - 대화를 하고 있는 현재 사용자들 목록
  - 지금 현재 보이고 있는 대화의 내용 
  - 리뷰가 되어야 하는 사용자들 목록(아직 다른 사용자들에게 보여지지 않음)
  - 사용자들이 현재 보고 있는 이미지의 데이터

**뷰를 담고 있는 컨테이너**
  - 이미지 카드 
  - 좋아요, 싫어요 버튼 
  - 대화 목록들 
  - 텍스트 아이템들(개인 메시지들) 
  - 텍스트 리스트(채팅 메세지들의 목록)

애플리케이션의 상태, 즉 자바스크립트의 한 객체에 애플리케이션이 필요한 모든 데이터와 관련된 상태들이 담겨있다고 보면 된다. 

--- 

### 리듀서 

리듀서는 하나의 애플리케이션 상태를 반환하는 함수이다. 리덕스는 여러가지의 상태를 가질 수 있고, 이에 따라서 여러 종류의 리듀서가 생길 수 있다. 

책을 보여주는 앱이 있다고 가정하자. 

**데이터를 포함하고 있는 컨테이너(리덕스)**
  - 책 리스트 
  - 현재 선택된 책 

**뷰를 포함하고 있는 컨테이너(리액트)**
  - 책 리스트를 보여주는 뷰 
  - 리스트가 포함하고 있는 아이템을 보여주는 뷰
  - 아이템의 상세 정보에 관한 뷰 

책 리스트와 현재 선택된 책에 관한 각각의 리듀서가 존재해야 하기 때문에 2개의 다른 리듀서들이 필요할 것이다. 

```js
// Application State - Generated by reducers

{
  books: [ {title: 'Harry Potter'}, { title: 'JavaScript'}], // Book Reducer
  activeBook: { title: 'JavaScript: The Good Parts'}
} // ActiveBook reducer

```

이제 상태의 값을 생성하는 함수를 만들어 볼 것이다.

리듀서를 위한 파일을 생성한 후, 함수를 작성한 뒤에 그 함수를 export하자. 그렇게 되면, 다른 파일에서 이 리듀서가 작성된 파일을 import할 때(책의 리스트가 있는) 자동적으로 책의 리스트가 담겨있는 리듀서를 불러올 것이다. 

그렇기 때문에 이것을 두 개의 작업으로 볼 수 있다.
1. 리듀서를 만드는 작업
2. 이 리듀서를 다른 파일들에 연결해주는 작업

이 리듀서를 리듀서 폴더 안에 있는 index.js(combineReducers라는 함수가 정의 된 곳)에 import 해야 한다. 

<!-- 1월 19일 챕터 40 -->

리덕스와 직접적인 연결이 없다면 이것은 view(dumb) component이다. 

인강의 예제에서 왜 book-list를 container로 만들지에 대한 과정을 알아보자.

예제 내의 app.js가 모든 상태를 가지고 가장 최상위에 위치하지 않겠냐는 질문을 던질 수가 있는데, app.js는 사실 book list에 대해 신경을 쓰지 않는다고 볼 수 있다. book-list가 book list에 대해 신경을 쓰는 것이다. 그리고 active book에 관한 것도 book-detail이 신경을 쓰는 것이다. 

app.js는 책의 리스트나 어떤 책이 선택되었는 지에 대한 것은 신경쓰지 않고,
여러 다른 페이지를 렌더해달라는 것이 전부이다. 그렇기 때문에 BookList와 BookDetail이 redux와 직접 연결되는 smart container가 될 것이다. app.js는 dumb component의 역할을 하는 것이다. 

그렇기 때문에 컨테이너(container component or smart component - 리덕스가 가진 상태에 직접적으로 접근할 수 있는 컴포넌트)를 생성할 때는 최상위 컴포넌트가 기능과 관련된 상태를 가지고 있어야(리덕스와 연결이 되어야 한다) 한다는 것이다. 자식 컴포넌트가 상태를 필요로 해도 그와 연결된 최상위 컴포넌트만 리덕스와 연결되어야 한다.  

<!-- 챕터 42 -->

그 후 `mapStateToProps(state)`라는 state을 매개변수로 받는 함수를 작성해 준다. 이 함수를 작성하는 이유는 이 애플리케이션의 상태(책의 리스트를 담은 배열, 현재 선택된 책)를 매개변수로 받는다. 이 함수에서 반환되는 값은 BookList 내에 props로 보여질 것이다.

`import { connect } from 'react-redux'` 해준 후,
`export default connect(mapStateToProps)(BookList)`와 같은 방식으로 export 시킨다. 

connect는 함수와(mapStateToProps) 컴포넌트(BookList)를 받아서 컨테이너를 생성한다. 이 컨테이너는 리덕스에 의해 관리되고 있는 상태를 인식하는 컨테이너이다. 

mapStateToProps 내에서 반환되는 것은 this.props로 접근할 수 있다. 이 함수는 리액트와 리덕스를 이어주는 아주 중요한 역할을 한다. 이 예제의 경우에서는 books라는 키를 가지고 state.books라는 값을 가진 것을 반환한다. state.books는 reducer에서 정의되는 books를 사용하기 위해 저렇게 쓰여졌다. 

connect를 사용해서 컨테이너를 생성하면,
1. 상태가 바뀌는 일이 발생한면 렌더가 다시 발생한다. 
2. 상태가 바뀌는 일이 발생하면, mapStateToProps내에 선언된 객체는 컴포넌트에 props로 할당된다.

<!-- 챕터 43부터 진행해야 함. -->