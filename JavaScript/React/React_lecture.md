# React: udemny online lecture

강의와 관련된 개발환경 설정

JSX : 부분적인 템플릿 혹은 변형된 자바스크립트로써, 자바스크립트 안에 HTML의 소스코드를 사용할 수 있게 해준다. 바벨과 같은 컴파일러를 통해서 바닐라 자바스크립트로 변환된 뒤에 화면에 표시된다.

React component를 화면에 그리기 위해서는:

1. React라는 라이브러리를 불러와야 하기 때문에 `import React from 'react';`를 해주는 것을 잊어서는 안된다.
2. 그리고 App.js(혹은 index.js)를 DOM에 붙인 뒤 화면에 그려주어야 하기 때문에 ReactDOM을 `'react-dom'`으로 부터 import를 해와야 한다.

DOM에 컴포넌트를 렌더하기 위해서는 컴포넌트를 인스턴스화 해야한다. 인스턴스화를 하기 위해서는 ReactDOM.render()안에 `<App />`이라는 인스턴스(App이라는 클래스가 아닌)를 렌더하라고 지정해주어야 한다.

인스턴스를 지정해주었다고 해서, 렌더가 되는 것이 아니다. 그 이유는 어디에다가 렌더를 해주어야 하는 지도 지정해주어야 하기 때문이다. 이는 index.html내에 있는 root를 찾아서 지정해주면 된다.

<!-- 섹션 1, 챕터 12 부터 시작 -->

# 2018-12-27

우리가 app을 만들 때, 어떻게 컴포넌트를 구성할 지 정해야 한다.

1. app 상단의 검색 바 컴포넌트

- 이는 검색하는 기능을 가지고 있고, 검색 바를 렌더링 할 것이다

2. app 중간에 비디오를 플레이하는 컴포넌트

- 역시 기능과 렌더링

3. 비디오의 프리뷰를 보여주는 컴포넌트

- 비디오의 프리뷰 썸네일과 타이틀을 포함

4. 3번의 비디오 프리뷰들을 포함하는 리스트를 보여주는 컴포넌트

5. 그리고 위의 4가지 모두를 포함할 하나의 전체 컴포넌트

파일 당 하나의 컴포넌트를 만들어야 한다.

## Youtube API를 사용해서 비디오 재생하는 컴포넌트의 생성

npm을 통해 youtube-api-search를 설치. 설치 시에 `--save`를 선언하면, 이는 package.json에 파일을 자동으로 저장해달라는 의미이다.

컴포넌트를 생성한 뒤에 export를 하지 않으면, 다른 컴포넌트에서 불러와 사용할 수가 없다. 그렇기 때문에 export를 하는 것을 잊지 말자!

```js
// 무언가를 export 할 때,

const SearchBar = () => {
  return <input />;
};

const foo = 5;

export default SearchBar;

// 위와 같은 선언은 foo는 제외한 SearchBar만 export 한다.
```

무언가를 import 해올 때, npm에서 설치된 패키지같은 경우에는 `from 패키지 이름`만 선언해줘도 되지만, 컴포넌트 같은 경우에는 import를 하려고 하는 파일의 상대 경로를 지정해서 불러와주어야 한다.

index.js에 search_bar.js를 렌더링 한다. index.js는 search_bar.js를 렌더링하고, 이 렌더링의 결과를 App 컴포넌트 안에 렌더링 한다. 이 App.js 컴포넌트는 div에 렌더링 할 것이고, 이 div는 index.js파일의 container라는 컨테이너 안에 위치한다.

리액트 컴포넌트의 형태

1. 함수형 컴포넌트
2. 클래스 컴포넌트

함수형 컴포넌트보다 클래스 컴포넌트가 더 많은 기능(상태라던지..)을 포함할 수 있다.

```js
// class component의 생성
// extends React.Component는 말 그대로
// 리액트 컴포넌트로부터 모든 기능을 제공받으라는 것이다
class SearchBar extends React.Component {}
```

함수형 컴포넌트로 시작할 지, 클래스형 컴포넌트로 시작할 지에 대한 고민은 무척 어렵다...

## Detecting handling events

`<input />` 안에:
`onChange`: 모든 HTML 인풋 요소에 change event가 발생하면 `onChange={함수}` 함수가 실행된다. 여기서 `onChange`는 prop이고 이 안에 함수를 쓰게 된다.

이벤트 핸들러 안에 들어갈 요소로써 이벤트 객체가 있는데 이는 e 또는 event라 정의할 수 있고, 어떠한 이벤트가 발생했는지를 알기 위해서는 `event.target.value` 등의 선언을 통해 입력이 되고있는 input 등을 바로 확인할 수 있다.

핸들러를 정의해줄 수도 있으나, 바로 적용시킬 수도 있다.

```js
// input 컴포넌트 내에 바로 적용시킨 것
class SearchBar extends Component {
  render() {
    return <input onChange={e => console.log(e.target.value)} />;
  }
}
```

## 상태 관리

함수형 컴포넌트는 상태를 가질 수 없고, 오직 클래스형 컴포넌트만 상태를 가질 수 있다.

```js
constructor(props) {
    super(props);

    this.state = {
      term: ""
    };
  }
```

위는 React component에서 상태를 정의하고 싶을 때 만드는 contructor이다.
Component가 constructor 함수를 가질 때:

- 부모 클래스에 메소드를 미리 정의했을 때 => component:
  - super를 호출하면서 이 부모 클래스의 메소드를 호출할 수 있다.

<!-- 챕터 18부터 다시 시작 -->
2019년 1월 14일

필요에 의해 Redux 부분부터 듣기로 했다. 챕터 34부터 시작.

## 리덕스 

### 리덕스는 왜 필요하고, 우리가 사용하면서 얻는 이점이 무엇일까?

리덕스는 앱을 표현할 수 있는 모든 데이터를 가지고 있는 컨테이너라고 볼 수 있다. 리액트는 이런 데이터를 뷰로 변환하여 보여주는 역할을 담당한다고 보면 된다. 

리덕스는 이 모든 데이터를 한 객체(상태 또는 state)로 집중시킨다. 

만약, 간단한 카운터(+, -와 현재 카운트를 보여주는)가 존재한다고 할 때, 이를 데이터를 담고 있는 컨테이너와 뷰를 담고 있는 컨테이너로 나눈다고 가정해보자. 그렇게 되면 데이터를 담고 있는 컨테이너에는 카운터의 현 상태를 담고 있는 current count라는 데이터가 들어있을 것이고, 뷰를 포함하는 컨테이너에는 current count를 보여주고, number change를 보여주는 뷰들이 포함되어 있을 것이다. 이 두 컨테이너들이 합쳐지면 사용 가능한 앱이 되는 것이다. 

리덕스는 앱의 상태를 담고 있거나, 어떠한 데이터를 뷰에 그릴지에 관한 정보를 담고 있다. 

---

리액트는 뷰를 컨트롤하고, 리덕스는 데이터를 컨트롤한다고 보면 쉽다. 

틴더라는 앱을 예로 들어서 리덕스와 리액트의 역할 분담을 이해해보자. 

**데이터를 담고 있는 컨테이너**
  - 사용자들(사용자의 이미지와 채팅 기록을 포함)
  - 대화를 하고 있는 현재 사용자들 목록
  - 지금 현재 보이고 있는 대화의 내용 
  - 리뷰가 되어야 하는 사용자들 목록(아직 다른 사용자들에게 보여지지 않음)
  - 사용자들이 현재 보고 있는 이미지의 데이터

**뷰를 담고 있는 컨테이너**
  - 이미지 카드 
  - 좋아요, 싫어요 버튼 
  - 대화 목록들 
  - 텍스트 아이템들(개인 메시지들) 
  - 텍스트 리스트(채팅 메세지들의 목록)

애플리케이션의 상태, 즉 자바스크립트의 한 객체에 애플리케이션이 필요한 모든 데이터와 관련된 상태들이 담겨있다고 보면 된다. 

--- 

### 리듀서 

리듀서는 하나의 애플리케이션 상태를 반환하는 함수이다. 리덕스는 여러가지의 상태를 가질 수 있고, 이에 따라서 여러 종류의 리듀서가 생길 수 있다. 

책을 보여주는 앱이 있다고 가정하자. 

**데이터를 포함하고 있는 컨테이너(리덕스)**
  - 책 리스트 
  - 현재 선택된 책 

**뷰를 포함하고 있는 컨테이너(리액트)**
  - 책 리스트를 보여주는 뷰 
  - 리스트가 포함하고 있는 아이템을 보여주는 뷰
  - 아이템의 상세 정보에 관한 뷰 

책 리스트와 현재 선택된 책에 관한 각각의 리듀서가 존재해야 하기 때문에 2개의 다른 리듀서들이 필요할 것이다. 

```js
// Application State - Generated by reducers

{
  books: [ {title: 'Harry Potter'}, { title: 'JavaScript'}], // Book Reducer
  activeBook: { title: 'JavaScript: The Good Parts'}
} // ActiveBook reducer

```

이제 상태의 값을 생성하는 함수를 만들어 볼 것이다.

리듀서를 위한 파일을 생성한 후, 함수를 작성한 뒤에 그 함수를 export하자. 그렇게 되면, 다른 파일에서 이 리듀서가 작성된 파일을 import할 때(책의 리스트가 있는) 자동적으로 책의 리스트가 담겨있는 리듀서를 불러올 것이다. 

그렇기 때문에 이것을 두 개의 작업으로 볼 수 있다.
1. 리듀서를 만드는 작업
2. 이 리듀서를 다른 파일들에 연결해주는 작업

이 리듀서를 리듀서 폴더 안에 있는 index.js(combineReducers라는 함수가 정의 된 곳)에 import 해야 한다. 

<!-- 1월 19일 챕터 40 -->

리덕스와 직접적인 연결이 없다면 이것은 view(dumb) component이다. 

인강의 예제에서 왜 book-list를 container로 만들지에 대한 과정을 알아보자.

예제 내의 app.js가 모든 상태를 가지고 가장 최상위에 위치하지 않겠냐는 질문을 던질 수가 있는데, app.js는 사실 book list에 대해 신경을 쓰지 않는다고 볼 수 있다. book-list가 book list에 대해 신경을 쓰는 것이다. 그리고 active book에 관한 것도 book-detail이 신경을 쓰는 것이다. 

app.js는 책의 리스트나 어떤 책이 선택되었는 지에 대한 것은 신경쓰지 않고,
여러 다른 페이지를 렌더해달라는 것이 전부이다. 그렇기 때문에 BookList와 BookDetail이 redux와 직접 연결되는 smart container가 될 것이다. app.js는 dumb component의 역할을 하는 것이다. 

그렇기 때문에 컨테이너(container component or smart component - 리덕스가 가진 상태에 직접적으로 접근할 수 있는 컴포넌트)를 생성할 때는 최상위 컴포넌트가 기능과 관련된 상태를 가지고 있어야(리덕스와 연결이 되어야 한다) 한다는 것이다. 자식 컴포넌트가 상태를 필요로 해도 그와 연결된 최상위 컴포넌트만 리덕스와 연결되어야 한다.  

<!-- 챕터 42 -->

그 후 `mapStateToProps(state)`라는 state을 매개변수로 받는 함수를 작성해 준다. 이 함수를 작성하는 이유는 이 애플리케이션의 상태(책의 리스트를 담은 배열, 현재 선택된 책)를 매개변수로 받는다. 이 함수에서 반환되는 값은 BookList 내에 props로 보여질 것이다.

`import { connect } from 'react-redux'` 해준 후,
`export default connect(mapStateToProps)(BookList)`와 같은 방식으로 export 시킨다. 

connect는 함수와(mapStateToProps) 컴포넌트(BookList)를 받아서 컨테이너를 생성한다. 이 컨테이너는 리덕스에 의해 관리되고 있는 상태를 인식하는 컨테이너이다. 

mapStateToProps 내에서 반환되는 것은 this.props로 접근할 수 있다. 이 함수는 리액트와 리덕스를 이어주는 아주 중요한 역할을 한다. 이 예제의 경우에서는 books라는 키를 가지고 state.books라는 값을 가진 것을 반환한다. state.books는 reducer에서 정의되는 books를 사용하기 위해 저렇게 쓰여졌다. 

connect를 사용해서 컨테이너를 생성하면,
1. 상태가 바뀌는 일이 발생한면 렌더가 다시 발생한다. 
2. 상태가 바뀌는 일이 발생하면, mapStateToProps내에 선언된 객체는 컴포넌트에 props로 할당된다.

<!-- 챕터 43부터 진행해야 함. -->

챕터 43은 위의 내용을 다시 복습하는 구간.

리덕스는 상태(데이터를 저장하는 컨테이너)를 제공하고, 리액트는 뷰를 제공한다고 볼 수 있다. 앱의 상태는 리듀서 함수에 의해 생성된다. 여기서는 reducer_books.js를 생성하여 책에 관한 정보가 담긴 객체들이 있는 배열을 반환시켰다. 이 book 리듀서를 리듀서 폴대 안에 생성되어 있는 index.js(리듀서를 총괄하는 js 파일) 내의 combineReducer 내에 선언해준다. 이 리듀서 함수는 books라는 키를 가지고 BooksReducer(reducer_books.js로부터 오는)라는 값을 가진, 이 객체 안에 선언된 것을 이 애플리케이션의 전역 상태에 선언하게 된다. 

그 이후에 books_list라는 컴포넌트를 생성한 뒤, 이 컴포넌트가 이 애플리케이션의 상태에 대해 인식해야한다는 것을 알고는 리덕스와 연결하기로 결정했다(컨테이너로 만들기로 결정함). 컨테이너(즉, 스마트 컴포넌트)로 만들기 위해서는 우선 connent를 임포트 하고, 그 뒤에 mapStateToProps 함수를 작성하고, export default connect를 이용해 리덕스와 연결한다. 

book_list를 컨테이너로 만들기로 한 결정의 배경은 오직 이 컴포넌트만이 앱의 전역 상태에 있는 BookList에 대해 알아야하기 때문이다(app.js같은 경우에는 BookList를 알 필요가 없다).

<!-- 챕터 44 액션과 액션 생성자 -->

이 예제의 문제가 하나 있다. 그 문제는 book reducer는 항상 같은 배열만 반환한다는 것이다. 지금 이 상태는 100% static(정적)인 상황이다. 시간이 지나도 지금 상태로는 이 상태에 변화를 줄 수 없다. 나중에 선택된 책이 어떤 것인지를 표시하게 해주려면 결국 상태의 변화를 나타낼 수 밖에 없다. 그렇기 때문에 동적인 상태도 표현할 수 있도록 코드를 작성해야 한다. 이를 위해서 action과 action creator를 사용해서 구현한다. 

**리덕스 action의 라이플 사이클**

리덕스 내에서는 대부분의 모든 상황에서 사용자가 직접적 혹은 간접적으로 이벤트를 발생시켰을 때 action이 작동한다. 버튼을 클릭하거나, 드랍다운 메뉴를 펼치거나 하는 것이 직접적인 이벤트 발생의 예라면, 간접적으로는 Ajax통신이 완료된다던지, 페이지의 로드가 완료된다던지가 될 수 있다. 이러한 행동들은 action creator를 선택적으로 호출할 수가 있다.

Action creator는 action을 반환하는 함수이다. 예를 들어, 사용자가 목록에서 책 하나를 클릭했을 때, action creator를 호출하게 되는 것이다. 그렇게 되면 action creator는 action을 반환하게 되는데, 이 action은 자동적으로 모든 리듀서들에게 전송이 된다. 리듀서들은 action의 종류에 따라 어떤 상태를 반환할 지 선택을 할 수가 있다. 만약에 여기서 상태를 반환하기로 한다면, 이 새로 반환된 상태는 애플리케이션의 상태에 넣어지게 되고, 이 상태의 추가 때문에 리액트가 다시 렌더링을 하게 된다. 

Action은 객체 안에 타입을 포함하고 있다. 그리고 action을 설명할 수 있는 데이터도 포함할 수 있다. 

리듀서에 action이 전송될 때, 그 안에서는 switch(action type) 선언문이 action이 어떤 타입을 가지고 있는지에 따라 실행된다.

그리고 만약 선택된 타입에 무엇을 반환할지 정해져 있다면, 그것을 반환하게 될 것이다. default 설정은 현재의 상태를 그대로 반환한다. 

그리고 이 스위치 문에서 반환되는 값이 애플리케이션의 새로운 상태 값으로 재할당이 된다.

>all reducers processed the action and returned new state. New state has been assembled. notify containers of the changes to state. On noticification, containers will render with new props.


<!-- 1월 20일 -->

이제 책을 클릭했을 때, 선택된 책이 보이도록 구현하기 위해서 actions 폴더 내에 index.js에 이와 관련된 action을 작성할 것이다. 

index.js 안에 selectBook이라는 book을 매개변수로 받는 함수를 작성하고 적용을 해야한다. 적용을 할 때, 이 함수를 book_list.js에 import하고 핸들러로 넘겨준다고 생각할 수도 있지만, 이 일은 그렇게 간단하지 않다. 

선언된 action으로 인해 반환되는 것이 모든 리듀서들을 거치도록 구현을 해야한다. Action creator가 리덕스에 연결되도록 해주어야 한다는 것이다.

book_list.js를 connect 훅을 사용해서 리덕스와 연결시켰던 것 처럼, 여기에다가 다시 bind를 통해 action creator와 연결해 줄 것이다. 

book_list.js로 돌아온 뒤, selectBook을 import 해주고, 그 다음에 bindActionCreators라는 훅을 redux로부터 import 한다. 

그리고 mapStateToProps 다음에는 mapDispatchToProps 함수를 작성하는데, 이 함수의 역할은 selectBook이 호출되었을 때 반환되는 값이 모든 리듀서들을 거치도록 하는 역할을 하도록 만들어주는 함수이다. 

mapDispatchToProps를 통해 반환되는 것들은 BookList container에 props로 전달될 것이다.

<!-- 챕터 46 -->

mapDispatchToProps를 통해 selectBook이 반환될 것이기 때문에 이것`(this.props.selectBook)`을 위에 `<li>`에 onClick 이벤트를 통해 사용할 수가 있다. 

index.js(actions 폴더 내의)로 돌아와서 selectBook에 타입을 정의해주려고 한다. return{} 내에 타입은 'BOOK_SELECTED'를 값으로 정해주고, payload는 book으로 정해줄 수 있다. 타입은 항상 대문자로, 그리고 대부분은 string을 사용하며 단어 별로 `_`를 사용하여 나누어줄 수 있다. 


<!-- 챕터 47 -->

이제 해야될 것은 active_book을 위한 리듀서를 작성하는 것이다.

리듀서는 state과 action을 매개변수로 받는다. 매개변수에 들어오는 state는 전역의 state가 아닌, 하나의 리듀서가 관련하는 state만 취급한다. 

만약에 작성된 리듀서와 관련없는 state이 들어오게 되면, 그냥 default state을 반환하도록 작성해줘야 한다. 

선택된 책을 보여주는 리듀서를 작성 시, 사용자가 아무 선택을 하지 않았을 시에 넘겨줄 default state이 필요하다. 리듀서는 undefined를 상태로 넘겨주지 않고 에러를 발생시키기 때문에 default state을 항상 설정해주어야 한다!

이 예제에서는, 매개변수 state에 null을 설정해준다. `state = null`(ES6에 추가된 기본값 설정법)을 해주면, state가 undefined가 반환되어도 이를 null로 반환해 줄 것이다. 

리듀서 안에서 값을 변경하는 행위를 해서는 안된다. 항상 오염되지 않은 객체를 반환해야 한다. 

리듀서 index.js에 ActiveBook을 import하고 combineReducers안에 선언해주자. 여기서, 키로 정의되는 객체가 바로 전역 상태의 키가 된다. 
---

**argument vs parameter**

parameter(매개변수)는 함수에 어떠한 값이 넘어오는지를 뜻해주고 argument(인자)는 함수로 넘어오는 실제적인 값을 뜻한다!

---

<!-- 챕터 48 -->

이제 선택된 책을 보여주는 book detail view를 만들 것인데, 이를 결정하기 위해서는 컴포넌트(VC)를 만들 것인지 컨테이너(CC)를 만들 것인지 결정해야 한다. 여기서는 우리가 어떤 책들이 있는지 알고, 언제 변경이 되는지 알기 때문에 이 컴포넌트는 리덕스에 연결될 수 있도록 컨테이너로 승격되어야 한다! 

결국, 위의 뜻은 app.js는 책의 리스트와 책의 자세한 사항(어떤 책이 선택되었는지)을 뷰로 보여주기만 할 것이기 때문에, 어떤 책이 선택되었는지는 book detail만 알고 있으면 된다. 그렇기 때문에 우리는 active_book 컴포넌트를 컨테이너로 만들 것이다. 

book-list를 리덕스와 연결했던 것 처럼 똑같이 하면 된다.

<!-- 챕터 49 조건부 렌더링! -->

리듀서가 실행될 때, 어떤 일이 일어나는 지를 알아보자. 

애플리케이션이 처음 실행될 때:
1. 액션이 들어온다. 타입이 뭔지는 모른다(이 예제에서는 앱이 켜졌을 때 책이 바로 선택되지 않기 때문에 어떠한 타입도 없다고 볼 수 있다).
2. 그렇기 때문에 일단 `return state`문이 실행된다. 
3. default값에 null을 넣어주었기 때문에 active book의 상태는 null값이 될 것이다. 
4. 그렇기에 book-detail 내에 작성한 this.props.book.title도 없는 것(`null`이니까)으로 간주 될 것이다. 이것이 에러를 발생시킨다.  

위의 상황을 방지하기 위해서, book-detail 내의 렌더 메소드에서 체크를 하는 코드를 작성해 줄 수 있다. 

<!-- 챕터 50 -->

기억하고 넘어가야 할 것

1. 리덕스는 애플리케이션의 상태를 관리하는 역할을 한다. 앱의 상태와 컴포넌트의 상태는 다르다! 이 둘은 완전 다르다. 이 앱의 상태는 리듀서들로 구성된다.

2. 리듀서 index 파일 안에 컨테이너의 상태를 담게 된다. 한 컨테이너의 모든 상태는 리듀서 index 파일 내에 선언된 이름으로 사용할 수 있다.

3. 리듀서는 애플리케이션의 상태를 바꾸는 역할을 한다. 액션이 dispatch되면 모든 리듀서들에 보내지면서 맞는 type이 있는지를 확인한다.

4. action creators는 action을 반환하는 매우 간단한 객체이다. 액션은 항상 타입이 있어야하고, payload가 필요하다. 관례적인 것이다.


<!-- 리덕스 중급과정 : 미들웨어 챕터 51부터 -->

무엇을 어떻게 계획해서 만들 것인가?

- 날씨 정보를 제공해주는 앱을 만들 것이다.
  1. 유저들은 서치바를 통해서 도시를 검색할 수 있다.
  2. 검색을 하면, API에 요청을 보내서 다음 5일간의 날씨 정보를 받아올 것이다.
  3. 유저들은 많은 도시 정보들을 한번에 확인할 수 있다.

리덕스가 모든 데이터 통신과 관련된 로직을 가져야하고, 리액트는 뷰와 관련된 역할만 해야한다. 

<!-- 챕터 52 -->

## 컴포넌트 셋업 
0. App 
  - 모든 하위의 컴포넌트를 렌더할 컴포넌트.

1. SearchBar 컴포넌트 
  - search input, search button을 포함한 상단에 위치할 컴포넌트 
  - 이곳에서 리덕스 액션이 발생할 것이다.(featching data)

2. ForecastList 컴포넌트
  - 리스트와 리스트 아이템을 한 컴포넌트에 넣어서 보여줄 것 같다. 

3. Chart 컴포넌트 
  - 차트에 관한 정보를 받아와서 여러개의 다른 정보를 표현하는 컴포넌트로, 재사용할 수 있도록 생성할 것.

## 컴포넌트가 컨테이너가 될 것인지, 컴포넌트가 될 것인지를 정하자 

1. SearchBar
  - 유저가 입력하는 도시의 정보를 요청해야하기 때문에 컨테이너가 되어야 한다. 

  - SearchBar 내에 사용되는 input은 controlled field(input에 입력되는 내용을 리액트(VC) 컴포넌트 상태에서 관리)화 시켜서 사용할 것이다. 

  - 이벤트 핸들러 생성 시, this.setState과 같은 무언가를 가리키는 코드를 사용할 때에는 bind를 생성자 안에서 연결해야 하는 것을 잊지 말자!

  - 유저가 엔터 혹은 submit 버튼을 눌렀을 때, 서버로부터 날씨 관련 데이터를 받아오는 로직이 필요하다.





