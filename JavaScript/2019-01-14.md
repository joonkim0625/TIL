# 2019-01-14

## Chapter 3 이어하기 - [이전 내용](2018-12-27.md)

## Numbers 

다른 언어들과는 달리, 자바스크립트는 정수 값과 부동 소수점 값을 구별하지 않는다. 자바스크립트에서 모든 숫자들은 부동 소수점 값들로 표시된다. 자바스크립트는 64 비트 부동 소수점 형식(IEEE 754 표준을 따르는)을 사용해 숫자를 표시하는데, 이 뜻은 작은 숫자는 ±5 × 10−324까지 표현이 가능하고 큰 숫자는  ±1.7976931348623157 × 10308까지 표현이 가능하다는 뜻이다.

자바스크립트의 숫자 형식은 −9007199254740992 (−253) 에서 9007199254740992 (253)까지 표현할 수 있도록 해준다. 만약 이보다 큰 수를 표현하려고 한다면, 소수점이 부정확해질 수도 있다. 하지만 자바스크립트 내의 어떠한 작업들은 32비트의 정수들을 사용한다(배열 인덱싱이라던지 비트 관련 연산들). 

자바스크립트 프로그램에 숫자가 표시될 때, 이를 숫자 리터럴이라고 부른다. 자바스크립트에서는 여러 형태의 숫자 리터럴들을 지원한다. 어떠한 수샂 리터럴들은 `-`를 앞에 붙임으로써 음수가 될 수 있다. 하지만 이는 숫자 리터럴 문법의 일부분은 아니다. 

### 정수 리터럴 

자바스크립트 프로그램 내에서는 10진수 기반으로 숫자들이 이루어져 있다. 예를 들면, 
```js
0
3
10000000
```

10진수 숫자들뿐만 아니라, 자바스크립트는 hexadecimal(16진수)로 이루어진 숫자들도 인식한다. Hexadecimal 리터럴은 "0x" 또는 "0X"로 시작되며 그 다음 자리에 문자가 온다. Hexadecimal 숫자는 0부터 9까지, 그리고 소, 대문자 a부터 f까지(10부터 15를 나타낸다)를 사용하여 나타낸다. 
```js
0xff // 15*16 + 15 = 255 (10진수 변환 시)
0xCAFE911
```

ECMAScript 표준이 8진수 리터럴을 지원하진 않아도, 자바스크립트는 정수 리터럴을 8진수의 형태로 표기할 수 있게 해준다. Octal(8진수) 리터럴은 0으로 시작하며, 0과 7의 숫자 중 하나가 한 자리에 올 수 있다.
```js
0377 // 3*64 + 7*8 + 7 = 255(10진수 변환 시)
```

8진수 표기를 지원할 때도 있고 아닐 때도 있기 때문에, 0으로 시작하는 정수 리터럴을 사용해서는 안된다. 우리는 0으로 시작하는 정수 리터럴을 사용했을 때, 이를 8진수 표기로 해석을 하는지 10진수 표기로 해석하는 지를 모르기 때문이다. ECMAScript 5 내에서의 'strict mode'에서는 8진수 리터럴은 금지되어 있다.

### 부동 소수점 리터럴 

부동 소수점 리터럴은 소수점을 가질 수 있다. 부동 소수점은 실수 표기를 위해 전통적인 문법을 사용한다. 실제 값은 소수점 및 숫자의 일부분으로 이루어진다. 

부동 소수점 리터럴은 지수 표기법을 통해서 표현될 수 있다: e(또는 대문자 E)가 실수 뒤에 붙을 때이다. 이는 정수에 10의 지수 값 만큼을 제곱하는 것과 같은 것이다. 

```js
// 위의 문법을 표현하면
[digits][.digits][(E|e)[(+|-)]digits]
```

실제 사용되는 예는:
```js
3.14
2345.789
.33333333333333
6.02e23     // 6.02 x 10^23
1.4738223E-32     // 1.4738233 x 10^-32
```

### 자바스크립트에서의 산술 연산 

자바스크립트 프로그램들은 산술 연산자들을 사용하여 숫자들을 계싼한다. 이는 `+`를 덧셈으로, `-`를 뺄셈으로, `*`를 곱셈으로, `/`를 나눗셈으로, 그리고 `%`를 나머지로 연산하는 것을 포함하는 것이다. 자바스크립트는 더 복잡한 수학적 연산자들을 Math 객체를 통해 제공한다. 

```js
// Math 객체가 제공하는 함수들의 예 
Math.pow(2,53)           // => 9007199254740992: 2 to the power 53
Math.round(.6)           // => 1.0: round to the nearest integer
Math.ceil(.6)            // => 1.0: round up to an integer
Math.floor(.6)           // => 0.0: round down to an integer
Math.abs(-5)             // => 5: absolute value
Math.max(x,y,z)          // Return the largest argument
Math.min(x,y,z)          // Return the smallest argument
Math.random()            // Pseudo-random number x where 0 <= x < 1.0
Math.PI                  // π: circumference of a circle / diameter
Math.E                   // e: The base of the natural logarithm
Math.sqrt(3)             // The square root of 3
Math.pow(3, 1/3)         // The cube root of 3
Math.sin(0)              // Trigonometry: also Math.cos, Math.atan, etc.
Math.log(10)             // Natural logarithm of 10
Math.log(100)/Math.LN10  // Base 10 logarithm of 100
Math.log(512)/Math.LN2   // Base 2 logarithm of 512
Math.exp(3)              // Math.E cubed
```

자바스크립트에서의 산술 연산은 overflow, underflow 또는 0으로 나누어질 때 에러를 발생시키지 않는다. 어느 결과가 표기할 수 있는 숫자보다 클 때(overflow), 그 결과는 특별한 무한의 값으로 표기된다(자바스크립트는 이를 `Infinity`로 표기). 비슷한 방식으로, 음의 값이 표시될 수 있는 음의 값보다 더 작아지게 되면 이를 `-Infinity`로 표기한다. 이 무한의 값들은 더하기, 빼기, 곱하기, 나누기에 대해 항상 무한대 값을 반환한다. Underflow는 수 연산의 결과값이 0보다 가까울 수 있는 숫자보다 더 작을 때 발생한다. 이런 상황에는 자바스크립트는 0을 반환한다. 만약 이러한 상황이 음수에서 일어난다면, 자바스크립트는 `negative zero`라는 특별한 값을 반환한다. 이 값은 0과는 구별이 거의 불가능하고, 자바스크립트 프로그래머들도 이에 관해 신경 쓸 일이 거의 없다.  

0으로 나누는 행위는 자바스크립트에서는 에러가 아니다. 이것은 단순히 무한대 또는 음의 무한대를 반환할 것이다. 하지만 한 가지 예외가 있는데, 0을 0으로 나누면 `NaN`(not a number) 값을 반환할 것이다. `NaN`은 무한대를 무한대로 나누려고 하거나, 음수의 제곱 근을 구하거나, 산술연산을 숫자로 변환될 수 없는 피연산자에 사용한다든지 할 때 발생한다. 

자바스크립트는 `Infinity`나 `NaN`같은 전역 변수들을 미리 선언해 놓았다. ECMAScript 3에서는 이 값들이 변경이 될 수 있는 값들이었는데, ECMAScript 5에서는 오직 읽을 수만 있는 값들로 바뀌었다. `Number`객체들은 ECMAScript 3에서부터 읽기만 가능한 변수들이었다. 이와 관련한 몇 가지 예가 있다: 

```js
Infinity                    // A read/write variable initialized to Infinity.
Number.POSITIVE_INFINITY    // Same value, read-only.
1/0                         // This is also the same value.
Number.MAX_VALUE + 1        // This also evaluates to Infinity.

Number.NEGATIVE_INFINITY    // These expressions are negative infinity.
-Infinity
-1/0                        
-Number.MAX_VALUE - 1

NaN                         // A read/write variable initialized to NaN.
Number.NaN                  // A read-only property holding the same value.
0/0                         // Evaluates to NaN.

Number.MIN_VALUE/2          // Underflow: evaluates to 0
-Number.MIN_VALUE/2         // Negative zero
-1/Infinity                 // Also negative 0
-0

```

`NaN` 값은 특이한 기능을 가지고 있다. 이 값은 다른 어떠한 값들과 비교해도 같다고 비교되지 않는다(자기 자신을 포함하여도!). 이 뜻은, `x == NaN`라는 x가 숫자인지 아닌지를 비교하는 연산을 할 수가 없다는 것이다. 대신에 `x != x`로 비교할 수가 있다. 이 `x != x` 연산은 오직 x가 `NaN`일 때에만, 또는 비교 대상이 문자열이나 객체같은 수가 아닌 값이여야만 `true`가 반환될 것이다. 

```js
const x = NaN 
x != x // true
```

음수 0값도 특이한 점 중 하나이다. 0과 -0값을 비교하면 같다고 나오는데, 이 뜻은 0과 음수 0는 거의 구별할 수 없을 정도로 같다는 것을 뜻한다.
```js
// 하지만 이 경우에는 다르다
var zero = 0;         // Regular zero
var negz = -0;        // Negative zero
zero === negz         // => true: zero and negative zero are equal 
1/zero === 1/negz     // => false: infinity and -infinity are not equal
```

### 2진수 부동 소수점과 반올림 오차 

이와 관련된 내용은 [helloworldjavascript](https://helloworldjavascript.net/pages/130-number.html)를 참고하였습니다. 

> 컴퓨터는 소수를 2진수를 이용해 저장하기 때문에, 위의 예제처럼 컴퓨터는 10진수 소수를 정확히 다룰 수 없습니다. 사실 우리가 코드 상에서 0.1이라는 값을 사용한다고 해도, 컴퓨터의 내부에서 다루어지는 0.1이라는 값에는 어느 정도의 오차가 존재합니다. 이 오차를 반올림 오차(rounding error)라고 합니다. 컴퓨터로 소수를 표현하는 방식으로 IEEE 754라는 표준이 널리 사용됩니다. 이 표준을 대부분의 프로그래밍 언어가 따르고 있어서 다른 프로그래밍 언어에서도 반올림 오차가 존재합니다.
> 그러면 사람들은 왜 이런 오차를 그냥 놔두는 것일까요? 이는 계산 상의 효율성을 위한 것입니다. 컴퓨터의 저장용량은 한정되어 있고 내부적으로 0과 1밖에 다룰 수 없으므로, 이런 제약 아래에서 10진수 소수를 아주 빠르게 계산하기 위해서 컴퓨터 설계자들이 이런 선택을 한 것입니다. 원주율과 같은 무한소수를 정말로 오차없이 다루려면 무한한 저장용량과 무한한 계산 성능이 필요하겠죠?
> 다만, 금융 분야와 같이 조금의 오차도 허용되지 않는 분야에서는 이런 오차가 큰 문제가 될 수 있습니다. 이 때에는 전용 라이브러리를 사용해서 문제를 해결할 수 있습니다만, 역시 자릿수 제한이나 연산 상의 제약이 존재하고, 무엇보다도 연산 속도가 느립니다. 그래도 정확도 면에서는 내장 실수 연산을 사용하는 것보다는 훨씬 낫죠.
> 실수 연산을 하는 프로그램을 만들 때에는, 본인이 어떤 유형의 실수 연산을 필요로 하는지 미리 파악한 후, 어느 쪽을 선택할 지 결정해야 합니다. 내장 실수 연산으로는 부족하다는 결론을 내렸을 때에는, decimal 혹은 big integer 등의 키워드로 검색해서 관련 라이브러리를 찾아보세요.


### 날짜와 시간 

자바스크립트는 날짜와 시간을 생성하는 `Date()` 생성자를 포함하고 있다. 이 Date 객체들은 간단한 시간 계산을 위한 API를 제공한다. Date 객체들은 숫자와 같은 기본적인 타입이 아니다. 간단한 Date 객체 사용 예제이다:
```js
var then = new Date(2010, 0, 1);  // The 1st day of the 1st month of 2010
var later = new Date(2010, 0, 1,  // Same day, at 5:10:30pm, local time
                     17, 10, 30);
var now = new Date();          // The current date and time
var elapsed = now - then;      // Date subtraction: interval in milliseconds 

later.getFullYear()            // => 2010
later.getMonth()               // => 0: zero-based months
later.getDate()                // => 1: one-based days
later.getDay()                 // => 5: day of week.  0 is Sunday 5 is Friday.
later.getHours()               // => 17: 5pm, local time
later.getUTCHours()            // hours in UTC time; depends on timezone

later.toString()               // => "Fri Jan 01 2010 17:10:30 GMT-0800 (PST)"
later.toUTCString()            // => "Sat, 02 Jan 2010 01:10:30 GMT"
later.toLocaleDateString()     // => "01/01/2010"
later.toLocaleTimeString()     // => "05:10:30 PM"
later.toISOString()    
```

--- 
<!-- 2019-01-22 -->

## Text

문자열은 16비트 값으로 이루어진 변경될 수 없는, 유니코드로 이루어져 있다. 문자열은 텍스트를 나타내는 자바스크립트의 타입 중 하나이다. 문자열의 길이는 문자열이 가지고 있는 16비트 값들의 수이다. 자바스크립트의 문자열은(그리고 배열들은) 0을 인덱싱의 처음으로 사용한다(인덱스 첫 번째를 가리키는 숫자는 0, 그 다음은 1, 이런 식). 빈 문자열은 길이 값으로 0을 가지고 있다. 자바스크립트는 스트링 하나만을 나타내는 특별한 타입은 없다. 단 하나만의 문자열을 나타내고 싶으면, 단순히 길이가 1인 문자열을 사용하면 된다. 

### 문자 리터럴 

자바스크립트에서 문자열을 입력하고 싶다면, `''`나 `""`를 사용해서 입력할 수 있다. `"`로 작성된 문자열은 `'`를 포함할 수 있다(그 반대의 상황도 가능).  

```js
""  // The empty string: it has zero characters
'testing'
"3.14"
'name="myform"'
"Wouldn't you prefer O'Reilly's book?"
"This string\nhas two lines"
"π is the ratio of a circle's circumference to its diameter"
```

ECMAScript 3까지는 문자열은 항상 같은 줄에 쓰여져야 했는데, ECMAScript 5부터는 라인브레이크(`\`)를 사용할 수 있어 여러줄에 텍스트를 입력하는 것이 가능해졌다. 문자열 마지막이 아닌 중간에서 라인브레이크를 하고 싶다면, (`\n`)을 사용할 수 있다.

```js
"two\nlines"   // A string representing 2 lines written on one line
"one\          // A one-line string written on 3 lines. ECMAScript 5 only.
 long\
 line"

```

주의해야 할 점은 영어 문자열을 사용할 때에 어퍼스트로피가 존재하기 때문에 그것을 표현하고 싶다면 `\`을 이용한 escape를 시켜야 한다. 

클라이언트 사이드 자바스크립트 프로그래밍에서는 코드가 HTML의 문자열 코드들을 포함할 수도 있고 자바스크립트의 문자열 코드들을 포함하고 있을 수 있다. HTML도 자바스크립트처럼 `''`또는 `""`를 사용하여 문자열을 표현할 수 있다. 그렇기 때문에 HTML과 자바스크립트를 같이 사용할 경우에는 어떠한 기호를 통하여 문자열을 표시할 것인지에 대한 통일이 중요하다. 

```js
// HTML에선 `""`이, JavaScript는 `''`을 사용..
<button onclick="alert('Thank you')">Click Me</button>
```

### 문자열에서 escape가 쓰이는 경우들 

자바스크립트에서 `\`(backslash)는 특별한 목적을 가진 문자다. 그 뒤에 따라오는 문자와 같이 사용된다면, 화면에 표시되지 않는 문자가 된다. 예를 들어, `\n`은 escape 문자로써 새로운 라인으로 넘어가게 한다. 

또 다른 예로써는 `\'`와 같이 escape가 사용되었을 때이다. 이 escape의 경우에는 `''`이 사용된 문자열에 어퍼스트로피를 추가하고 싶을 때 사용된다.

`\`가 escape라고 불리는 이유는, `\`를 사용함으로써 기존의 문자가 해석되는 방식이 아닌 다른 방식으로 표현이 되기 때문이다. 

```js
// 위의 경우를 나타낸 예
'You\'re right, it can\'t be a quote'
```

아래의 표는 자바스크립트에서의 escape의 종류들이다.

| Sequence | Character represented |
| ----------- | ----------- |
| `\0` | The NUL character (`\u0000`) |
| `\b` | Backspace (`\u0008`) |
| `\t` | Horizontal tab (`\u0009`) |
| `\n` | Newline (`\u000A`) |
| `\v` | Vertical tab (`\u000B`) |
| `\f` | Form feed (`\u000C`) |
| `\r` | Carriage return (`\u000D`) |
| `\"` | Double quote (`\u0022`) |
| `\'` | Apostrophe or single quote (`\u0027`) |
| `\\` | Backlash (`\u005C`) |
| `\x XX` | The Latin-1 character specified by the two hexadecimal digits XX (`\u000D`) |
| `\u XXX` | The Unicode character specified by the four hexadecimal digits XXXX (`\u000D`) |

`\`가 저 위의 표 외의 다른 문자와 같이 사용된다면, `\`는 무시된다. 만약 `\#`를 사용하게 된다면, 화면에는 `#`만 표시될 것이다. 마지막으로 ECMAScript 5는 라인 브레이크가 여러 줄의 문자를 브레이크 하기 전에 backlash의 사용을 허용한다.

### 문자열을 사용하기 

자바스크립트에 내장된 기능 중에는 문자열들을 연결시키는 기능이 있다. 만약 사용자가 `+` 연산자를 숫자에 사용한다면, 이는 숫자들을 더할 것이다. 하지만 이 연산자를 문자열에 사용한다면, 두 번째의 문자열은 첫 번째의 문자열 뒤에 붙게 된다. 

```js
msg = "Hello, " + "world";   // Produces the string "Hello, world"
greeting = "Welcome to my blog," + " " + name;
```

문자열의 길이를 알고 싶다면(16비트의 값을 포함하는 길이의 숫자), `length`을 사용하여 알아낼 수 있다. 

```js
// string s
s.length
```

length 속성 말고도, 문자열에 사용할 수 있는 여러가지 method들이 있다. 

```js
var s = "hello, world"        // Start with some text.
s.charAt(0)                   // => "h": the first character.
s.charAt(s.length-1)          // => "d": the last character.
s.substring(1,4)              // => "ell": the 2nd, 3rd and 4th characters.
s.slice(1,4)                  // => "ell": same thing
s.slice(-3)                   // => "rld": last 3 characters
s.indexOf("l")                // => 2: position of first letter l.
s.lastIndexOf("l")            // => 10: position of last letter l.
s.indexOf("l", 3)             // => 3: position of first "l" at or after 3
s.split(", ")                 // => ["hello", "world"] split into substrings
s.replace("h", "H")           // => "Hello, world": replaces all instances
s.toUpperCase()               // => "HELLO, WORLD"
```

기억해야 할 것은, 문자열은 자바스크립트에서 불변하다는 것이다. `replace()`를 사용하거나 `toUpperCase()`를 사용하여도, 이 method들은 새로운 문자열을 반환시킨다. 이 뜻은 기존의 문자열에는 변경이 가해지지 않는다는 것이다. 

ECMAScript 5에서는 문자열들은 읽을 수만 있는 배열들로 취급되기도 한다. 그리고 이 각각의 문자들(16비트 값들)을 `charAt()` method 대신 `[]`을 사용해서 접근할 수 있다.

```js
s = "hello, world";
s[0]                  // => "h"
s[s.length-1]         // => "d"
```

모질라를 기반으로 한 파이어폭스 같은 브라우저들은 문자열들이 이렇게 인덱스화 될 수 있도록 오랜 기간동안 허용해 놓았다. IE를 제외한 최근의 브라우저들은 모질라의 이러한 점을 ECMAScript 5가 이 기능을 포함하기도 전에 사용하고 있었다. 

### 정규 표현식(patter matching)

자바스크립트는 `RegExp()`를 텍스트들의 패턴을 나타내는 객체를 만들어내는 생성자로 정의하였다. 이 패턴들은 정규 표현식으로 묘사되며, 그리고 자바스크립트는 Perl의 정규 표현식 문법을 적용하였다. 문자열과 정규표현식 객체는 정규 표현식을 통해 패턴 매칭이나 검색 후 대체하기 등의 작업들을 수행한다. 

정규 표현식은 자바스크립트의 기본적인 타입이 아니다. 정규 표현식은 날짜와 같이 특별한 형태의 객체이다. 정규 표현식 문법은 복잡하고 방대하다. 하지만 정규 표현식은 매우 강력하고 텍스트를 관리하는데 있어서 자주 사용되기 때문에 이 섹션에서는 간략하게 소개한다. 

정규 표현식이 자바스크립트에서 기본적인 데이터 타입이 아닐지라도, 자바스크립트 프로그램에 바로 변환될 수 있는 리터럴 문법을 가지고 있다. `/`로 시작하고 끝나는 표현식 내에 이 정규 표현식과 관련한 문법이 정의된다. 마지막 `/`가 끝나고 나서 하나의 추가적인 문자가 올 수 있는데, 이 추가적인 문자가 표현식을 정의하게 된다. 예를 들면: 

```js
/^HTML/              // Match the letters H T M L at the start of a string
/[1-9][0-9]*/        // Match a non-zero digit, followed by any # of digits
/\bjavascript\b/i    // Match "javascript" as a word, case-insensitive
```

정규 표현식은 몇 가지의 유용한 method들을 가지고 있고 문자열들 또한 정규 표현식을 받을 수 있는 method들이 있다. 

```js
var text = "testing: 1, 2, 3";   // Sample text
var pattern = /\d+/g             // Matches all instances of one or more digits
pattern.test(text)               // => true: a match exists
text.search(pattern)             // => 9: position of first match
text.match(pattern)              // => ["1", "2", "3"]: array of all matches
text.replace(pattern, "#");      // => "testing: #, #, #"
text.split(/\D+/);               // => ["","1","2","3"]: split on non-digits
```

---

## Boolean 값

