# 11-27-18

### defaultProps

- prop의 사용법이라고 볼 수 있다.

```js
// 주석에 어떠한 역할을 하는지 설명을 적어주자
PostForm.defaultProps = {
  // true가 주여지면, 편집 모드 스타일이 적용됨
  editing: false
};
```

클래스 필드를 사용해 가독성을 높여줄 수 있다.

사용 시 주의사항

- 기본값을 설정한다는 것은(빈 함수라도) 무언가 값이 없어도 동작이 되는 것이기 때문에 주의해야 한다 -> 빈 함수를 넣는다는 것은 값이 아무것도 넘겨지지 않아도 작동을 한다는 것이기 때문.
- 그렇기 때문에 값이 없으면 동작을 하지 않아야 하는 상황이라면, `null`을 사용해서 함수가 넘겨지지 않으면 작동을 하지 않게 설정해주어야 한다.

또 다른 기법들은 :

- proptypes라는 라이브러리를 사용할 수 있다.
- TypeScript를 사용할 수 있다.

---

### storybook action 기능

```js
// 테스트를 위한 actions 객체를 생성해서 사용하자
const actions = {
  onSubmit: action("onSubmit")
};

storiesOf("PostForm", module)
  // 이 함수 줄은 자기한테 들어온 함수를 그대로 반환한다.
  // 테스트 함수를 쉽게 만들 수 있다.
  .add("default", () => <PostForm {...actions} />)
  .add("editing", () => <PostForm {...actions} editing={true} />);

// 스토리 북의 다른 페이지로 넘기고 싶다면,
// onSubmit={linkTo('PostDetailView)}
// 와 같이 입력하면 스토리북 내의 PostDetailView로
// 페이지가 이동한다
```

**구현 세부사항(implementational details)**

- 코드를 사용하는 쪽에서는 코드의 구현 세부사항에 관한 것을 모른 채로 사용할 수 있어야 좋은 것이다.

---

### Loading Indicator

공통적으로 적용시킬 수 있는 로딩인디케이터(세부적인 페이지마다의 로딩 인디케이터도 존재하니까)를 HOC 기법을 사용해 적용시킨다.

---

웹펙에서는 index.js에서 entry point(의존성 분석을 시작하는 파일)가 시작하고, storybook에서는 .config에서 entry point가 시작한다.

웹사이트와 스토리북(index.js를 거치지 않는다)의 엔트리 포인트가 다르기 때문에,

---

### 프로젝트 시, 컴포넌트 나눌 시 어떤 기준으로?

헤더, 푸터, 사이드바 정도는 대부분의 레이아웃에서 공유를 한다.

페이지라는 큰 하나의 영역과 컨테이너라는 영역을 다르게 생각해야 한다.

페이지 컴포넌트는 모든 화면에 사용되는 요소를 담고 있다.

- 라우트 컴포넌트의 컴포넌트 prop에 사용된다는 특징이 있다.

그리하여...

1. 제일 작은 단위의 컴포넌트는 프레젠테이셔널 컴포넌트
2. 그것을 감싼 컨테이너 컴포넌트
3. 저 위의 것들을 감싼 페이지 컴포넌트
4. 저 페이지 컴포넌트를 react-router에 붙여주면 된다.

저 위의 작업은 작업의 규모가 커지거나, 분리를 하고싶을 때 실행하면 된다.

---

비슷한 것을 찾아서 재사용할 수 있는 것이 있는지를 찾아보아야 한다.

##### 망고플레이트

prop을 넘겨서 스타일링 - 어느 페이지에서는 검색기능이 보일 때가 있고 어느 페이지에서는 검색기능이 보이지 않을 때가 있는데, 스타일이 거의 비슷할 때.

- 검색바 true, false 이런 식으로...

고정된 헤더섹션이 필요

검색 기능 자체는 같아 보이기 때문에, 기능을 담당하는 컨테이너 컴포넌트를 만들어서 사용할 수 있다. 하지만 모양(view)은 다르기 때문에:

```js
class Search extends Component {
  render() {
    // 컴포넌트도 입력받을 수 있다.
    const { SearchField } = props;
  }
}
```

기능이 같아도 view가 다르다면 컴포넌트를 prop으로 받아 해결할 수 있다.

베스트 15곳, 건강빵집 10곳... 이런 것들이 다 각각의 컴포넌트가 될 수 있다.

검색결과를 출력하는 기능을 담는 search list 컴포넌트를 만들 수 있다. 또한 성수동 검색결과를 즐겨찾기에 등록할 수 있게 만들어야 한다. 이 뜻은 지역을 검색할 때마다 주소가 바뀌어야하기 때문에 주소를 바꾸는 역할을 하는 컨테이너와 주소가 바뀌었을 때 표시해주는 컨테이너가 있어야 할 것이다(match라는 prop을 보고 주소와 일치하는 검색결과를 보여주도록). 주소를 받은 뒤에 바로 표시해주는 것은 적합하지 않다.

##### 배민찬

헤더영역은 무조건 컴포넌트로 만들어야 할 것이다(고정되어 있음).

- 로그인 한 뒤에는 유저 컨슈머로 둘러싼 컨테이너로 만들어 줄 수 있다(로그인이 된 상태 때는 로그아웃이 보여지고... 이런 식의 기능)

역시 검색기능이 있는 곳은 주소를 바꾸는 컨테이너가 있고, 그 주소에 따라서 결과를 보여주는 컨테이너가 따로 존재해야 한다.

큰 리스트 프레젠테이셔널 컴포넌트가 있고 그 안에 작은 세세한 컴포넌트(각각의 식당)을 보여주는 컴포넌트를 작성할 수 있다.

인기순 드랍다운을 클릭해서 다른 보기로 가면, 이 역시 주소가 바뀐다. 셀렉트 박스이자 주소를 바꿀 수 있는 컴포넌트를 생성해야 할 것이다. 그리고 주소가 바뀜에 따라 그것을 정렬해주어야 한다.

장바구니 컨테이너가 필요하고 그 안에는 가격이 변하는 상태가 필요할 것이다. 수량같은 것을 제어되는 컴포넌트로 만들어서, 변경이 될 때마다 상태를 바꿔주고 총가격을 업데이트하는 식으로 해줄 수 있을 것이다.

##### 요기요

똑같이 하면 이상해질 수 있다... 주의 요망...

주소체계가 아마도 우편번호인 듯. 그럴려면 우편번호 베이스가 필요할 것인데...
그러지 말고 사당동은 sadang, sinsa(예제) 등을 만든 다음에 입력되었다면 그에 맞는 검색 결과를 보여주면 될 것이다...

주소 검색과 메뉴검색 필드가 따로 존재한다. 주소검색용 pc, cc를 만들 것이고 상호(메뉴) 검색용 pc, cc를 따로 생성하는 것이 맞을 것.

상호나 메뉴 검색 시 주소가 바뀌지 않는다.
주소 검색 시 : 주소의 상태(주소 자체)를 바꾸어 준다.
메뉴 검색 시 : 컨테이너의 리액트 상태를 바꿔서... 다시 화면을 그려준다...

매장 정보는 컴포넌트 하나를 만들어서 다 공유하면 될 것이다.

##### cgv

영화가 선택되고, 날짜가 선택되고, 장소가 선택될 때마다 상태가 저장되고 공유되어야 다음으로 넘어갈지 말지가 판단될 것이다.

##### 에어비앤비

검색을 하면 주소에 검색 시 입력한 주소에 담은 후 다음 페이지에 넘겨준다.

검색 조건이 입력되어 있는 상태에서 그것을 사이드바에 있는 검색 조건을 고치고 검색을 다시 하면, 주소상태가 바뀌며 화면상태가 바뀐다.

공유되는 것이 많지 않으니, 여러 개의 컨테이너 컴포넌트를 담는 통을 하나 만들어서 담는다고 보면 된다.

---

React Helmet
문서의 head를 매니지하는 것을 도와준다.
