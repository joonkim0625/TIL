# 11-29-18

### 실습 관련 내용 노트


서버와 프레젠테이셔널 컴포넌트의 구조가 의존성을 가지고 있으면 나쁜 설계이다.
프레젠테이셔널 컴포넌트의 구조는 최대한 간단하게 유지하는 것이 좋다 - 그래야 재사용하기가 쉽다.

로딩 인디케이터 같은 경우… 프로덕트 리스트 밑에 있는 애한테 둘러줘야 한다 - 자기 자신한테 prop을 내려줄 수 없기에

---

주소설계
/홈
/product/1 상품정보

route 사용 시, switch 말고도 ` <Route exact path="/" component={HomePage} />` 이렇게 exact 프롭이 있을 때는 주소가 정확히 일치해야만 페이지가 그려진다.

switch 사용 시, 주소 path가 일치하면 원하지 않는 목록이 나올 수 있으니, 홈 디렉토리는 맨 마지막에 위치시키거나 exact prop을 붙여준다.

---

새탭에서 열기도 잘 지원해야하기 때문에 link는 꼭 a 태그로!

---

레이아웃으로 헤더와 푸터를 고정시킬 수도 있지만, 헤더따로 푸터 따로 만들어서 페이지마다 붙이기도 가능하다.

요청횟수를 줄이는 것이 프론트엔드에선 매우 중요하다!

`https://fate-tomato.glitch.me/products/1?_embed=options`
상품의 옵션을 불러오려면...

상품의 옵션 배열 (요청횟수가 증가함 )`https://fate-tomato.glitch.me/products/1/options`

---

딱 그 UI(외부와 연동없는 내부 자체의 상태변화) 자체의 대한 상태변화라면 PC 안에 상태를 두어도 괜찮다(외부와 연결되어서 연동을 위한 상태변화는 두면 안된다!).

---

React에서는 selected prop을 주는 것은 바람직하지 않다. 그 대신, defaultValue나 value 값을 설정해주는 것이 권장되는 방식이다.

value prop에 null이 넘겨지면 제어되지 않는 컴포넌트가 되기 때문에, null값을 넘겨주면 안된다
  - null값 대신 빈 문자열을 넣어줄 수 있다.


prop 전달해줄 때
  - `onCreatecCartItem={this.handleCreateCartItem.bind(this)` 이렇게 this로 고정시켜서 묶어 내려보내주는 법.
  - 혹은 handleCreateCartItem 화살표 함수를 사용하여 클래스필드 문법으로 작성한 뒤 ` onCreatecCartItem={this.handleCreateCartItem}` 이렇게 적용시킬 수 있다.


---

유저 정보같이 전역에서 쓰여아 하는 컨텍스트는 App.js에 유저프로바이더를 씌어줄 수 있다.

리다이렉트 컴포넌트를 렌더링 하면 부작용이 발생하는데, 이 부작용은 주소표시줄의 상태를 사용자가 클릭하지 않아도 바뀌게 할 수 있는 작용을 한다.

실무에서 프레젠테이셔널 컴포넌트를 HOC로 감싸서 컨테이너 컴포넌트로 사용하는 패턴이 많이 사용된다(우리 실습에서는 Header 컴포넌트를 만든 과정).

프로바이더에서 내려지는 값이 바뀔 때마다 컨수머가 다시 그려진다.

**비교조정**
엘리먼트 타입이나 키가 바뀌면 상태가 날아간다. 
