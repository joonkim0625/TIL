# 11-12-18

### 횡단관심사(Cross-cutting concern)

로그인과 관련된 처리, 혹은 로딩 인디케이터 등 여러 부분에 걸쳐 적용되어야 하는 것 때문에 발생하는 코드 중복.

### 고차함수

### textContent vs innerHTML 의 차이?

- Element.innerHTML 은 HTML 의 자체를 반환한다. textContent 는 이것에 적용된 값을 HTML 로 parsing 하지 않는다. textContent 는 [XSS attcks](https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting) - cross-site scripting 을 방지할 수 있다.

### 코드 패러다임 : 명령적 vs 선언적

명령적 : DOM API - 코드를 써놓은 순서대로 코드를 실행. 하지만 결과물을 확인하기 쉽지 않다. 코드의 실행 흐름등을 해석해야 한다.

선언적 : HTML 은 작성된 것을 보여주고 작성된 순서등에 영향을 받지 않는다. 코드가 생긴대로 결과물이 나오기 때문에 코드가 결과물의 구조를 잘 반영한다.

### 새로 그리기 vs 필요한 부분만 고치기

새로 그리기 : 사람에게는 good, 기계한테는 bad

필요한 부분만 고치기 : 사람에게는 bad(유지보수가 불가능한 상태까지 도달), 기계한테는 good

---

[리액트 튜토리얼](https://reactjs-org-ko.netlify.com/tutorial/tutorial.html)

```js
class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhatsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    );
  }
}

// 사용 예제: <ShoppingList name="Mark" />
```

위에서 component 는 class 고, UI(`render()` 메소드)를 반환한다. 여기서 작성된 것들은 HTML 이 아니다!! 저 HTML 요소들 처럼 보이는 것들은 React 엘리먼트(무엇을 그릴지에 대한 정보를 담고있는 객체)이다. 이 `div, h1, ul, li`...들의 요소들은 모두 객체이다.

---

vue : 어떻게 그릴건지를 설명하는 값을 뷰라고 부른다.

컴포넌트를 태그처럼 사용할 수 있다.

state(상태): 프로그램을 실행시키기 위해 기억해야하는 모든 것.

### Tic Tac Toe 실습 중 노트

```js
class Square extends React.Component {
  constructor(props) {
    // 서브클래스의 생성자를 정의할 때는 반드시 super를 호출해주어야 한다.
    // super를 함수처럼 호출하면 -> 부모클래스의 생성자를 호출하는 코드가 된다.
    // 리액트 컴포넌트의 생성자를 정의할 때에는 super(props)가 반드시 맨 위에 위치해야 한다. 그렇지 않으면 에러가 난다. 반드시 필요한 코드!

    super(props);
    this.state = {
      value: null,
    }
  }
```

```js
// this.props.value => 부모로부터 내려받은 속성 중 value라는이름을 가진 애를 사용해서 쓰겠다.
// this.state.value => 나의 상태에 저장된 애를 가져다 쓰겠다.
// setState의 기능 두 가지: (두 가지의 변경을 동시에 하고싶다면무조건 setState을 사용!! -> 상태변경이 일어났을 때 자동적으로 화면이갱신이 된다. 리액트에서는 화면을 다시 그리고 싶다면, 상태를 바꿔줘야한다.) 리액트에서는 화면을 다시 바꿔주는 기능이 setState밖에 없다.(리액트는 화면을 다시 그려야할 때마다 component의 render method를계속 호출해서 확인하고 그려준다 -> 상태를 바꿈으로써 화면을 다시그린다.)
// 1. 상태 변경
// 2. 화면 갱신
render() {
    return (
      <button className="square" onClick={() => this.setState({value: 'X'})}>
        {this.state.value}
      </button>
    );
  }
}
```

```js
class Board extends React.Component {
  renderSquare(i) {
    // 스퀘어 컴포넌트에서 만들어진, 스퀘어 엘리먼트를 반환하는 것이다.
    // 리액트 엘리먼트에 어트리뷰트를 적어주면 밑의 'value'처럼 그것은 props 객체의 속성이 된다.
    // 이제 value와 같은 어트리뷰트를 prop이라고 보면 된다.
    // 정보의 흐름은 위에서 아래로(부모에게서 자식에게로) 흐른다.
    return <Square value={i} name="Square" />;
  }

  render() {
    const status = 'Next player: X';

    return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}
```
