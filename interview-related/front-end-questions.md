# 2019-01-11

하이어링데이에서 받았던 질문들을 정리!

---

**자바스크립트**
자연수가 2진수인지를 확인하는 가장 빠른 방법은?
var, let , const의 특성은?

---

**리액트 관련**

리액트의 장점?

MVC 패턴에서 리액트의 어떤 컴포넌트들이 MVC 패턴과 맞는 역할을 하는가?

- Model은 database라고 생각할 수 있으며, 데이터베이스로부터 데이터를 처리하는 곳이라고 볼 수 있다.오직 controller와만 연결되어 있다.

- Controller는 서버 사이드의 로직을 처리하는 곳으로 view와 model 사이를 이어주는 middleware 역할을 한다고 볼 수 있다. 데이터의 흐름을 관리한다. 

- View는 데이터를 시각화하여 사용자들에게 보여준다. 오직 controller와만 연결되어 있다.

**MVC** 패턴의 장단점은?

pros
  - 쉬운 코드를 작성함으로써 재사용성과 보수/유지를 더 쉽게해준다.
  - 분리가 되어있으므로 팀 내에서 협업하기가 편하다.
  - 다양한 뷰를 제공할 수 있게 해준다.
  - 비동기식 코드의 작성에 용이하다.

cons
  - 셋업 과정을 더욱 복잡하게 한다.
  - 모델과 컨트롤러에서 변경이 일어나면, 전체에 영향을 준다. 즉, 의존성이 발생하게 된다. 

MVC 패턴을 리액트에 적용하면?
  
  - MVC 패턴의 문제점은 양뱡향 커뮤니케이션 때문인데, 이는 디버깅을 힘들게하고 한 곳에서의 변경이 전체에 영향을 끼치기 때문에 이를 알아내는 것이 힘들다.
  
  - 앱의 규모가 커지게 되면 데이터의 흐름을 이해하기 매우 힘들어진다.

  - 그래서 페이스북은 자신들만의 디자인 패턴인 'Flux'를 고안해냈는데, 이는 Actions(속성과 데이터를 가진 객체들), Stores(앱의 상태와 logic을 포함), Dispatcher(작성된 action과 콜백들을 처리), 그리고 View(store로부터의 변경점들을 인지하고 화면을 새로 그림)라는 4가지의 중요 요소들로 구성되어 있다.



리액트에서 상태 끌어올리기는 왜 필요한가?

- 일부 컴포넌트가 동일한 데이터 변경을 반영해야할 때가 있는데, 이럴 때 공통이 되는 조상 컴포넌트에 state를 두는 것이 도움이 된다. 그로 인해서 한 번의 변경으로 필요한 컴포넌트들에 반영을 동시에 해줄 수 있기 때문이다.

리액트의 데이터 통신은 언제 발생하는가?

로그인은 어떻게 구현된 것인가? 페이지를 렌더링할 때마다 token 존재의 유무를 보는 것인가?

리액트가 데이터 통신을 하는 자세한 과정 

리액트가 컴포넌트를 불러왔을 때(화면에 그렸을 때) 데이터 통신을 하는 횟수

---

### 서버 사이드 렌더링 vs 클라이언트 사이드 렌더링 
[참고한 글 - https://www.elephate.com/blog/ultimate-guide-javascript-seo/](https://medium.com/@benjburkholder/javascript-seo-server-side-rendering-vs-client-side-rendering-bc06b8ca2383)

SSR과 CSR 뿐만 아니라 SEO와 관련된 이야기도 포함되어 있다. 

#### JavaScript SEO는 무엇인가? 

핵심적으로는 검색 엔진에 우리가 렌더할 페이지들이 검색의 최상위에 올라가도록 자바스립트를 통하여 작업하는 것이다. 이것은 CSR과 자바스크립트 프레임워크들의 사용증가와도 관련이 있다. 더 알아보기 전에, CSR과 SSR이 무엇인지를 알아보자.

#### Server side rendering(SSR)

전통적인 렌더링 방법으로써, 웹 사이트와 관련된 모든 자원들이 서버에 저장되어 있다. 페이지가 불러와질 때, HTML이 브라우저에 전송되고 렌더되며 자바스크립트와 CSS가 다운로드 된다. 그리고 나서 마지막 렌더링이 유저 혹은 bot에 나타난다.

#### Client side rendering(CSR) 

최근의 렌더링 기법이라 볼 수 있으며, 이 기법은 자바스크립트 프레임워크나 라이브러리를 통해 클라이언트 쪽(브라우저)에서 자바스크립트를 실행시키는 것에 의존한다. 기본적으로 클라이언트는 인덱스가 가능한 가장 조금의 HTML 파일을 불러온 뒤에 자바스크립트 안에 문자열로 짜여진 HTML 코드들을 불러올 것이다.

#### SSR과 CSR이 어떻게 다른가?

SSR이 첫 요청에서는 약간 빠를 수 있다(단순히 많은 요청을 서버로 하지 않기 때문이다). 하지만 성능적인 면은 또 다른 추가적인 이유들에 의해 영향받을 수도 있다. 아래의 목록들이 사용자 경험에 영향을 미칠 수 있는 것들이다:

  - 사용자가 사용하는 인터넷 속도
  - 얼마나 많은 사용자들이 사이트를 사용하고 있는지
  - 서버의 물리적 위치 
  - 페이지들이 얼마나 최적화되어 있는지 
  - 기타 등등...

반면에 CSR은 여러번의 요청을 서버로 보내기 때문에 초기 렌더링에서 느릴 수 있다. 하지만, 이 요청들이 끝난 후에는 CSR이 매우 빠른 사용자 경험을 자바스크립트 프레임워크를 통해 제공한다. 

Adam Zerner는 이러한 비유를 했다
> SSR은 당신이 새로운 페이지를 보기 위해서는 밖에 나가서 가져와야하는, 무엇인가를 먹고 싶다면 그때마다 슈퍼마켓에 가서 음식을 사 오는 것이다. CSR은 당신이 45분이 걸려서 슈퍼마켓을 가지만, 가서 한 달 치 음식을 사 온 다음에 먹고 싶을 때마다 꺼내서 먹는 것이다.

#### 왜 이러한 트렌드가 발생하고 있는 것인가?

자바스크립트 프레임워크들의 사용이 증가하면서(앵귤러, 리액트, 뷰) 개발자들은 이제 웹페이지들을 더욱 효율적으로 전송할 수 있고 매우 빠른 속도의 사용자 경험을 제공할 수 있다. 하지만 제대로 계획하지 않고 웹사이트 개발을 한다면, 이는 SEO 조건을 충족시키지 못하는 값비싼 대가를 치를 수도 있다.

과거에는 자바스크립트는 웹페이지에 다양한 상호작용(인터랙션)을 추가하기 위해 사용되었다. 제이쿼리 등의 라이브러리들을 통해 위의 작업을 했다. 자바스크립트는 단순히 이미 소스코드에 표시된 HTML 콘텐츠들 위에 인터랙션을 추가하는 것이었기 때문에 검색 엔진들이 이 콘텐츠들을 발견하고 인덱싱(indexing, 색인)하는 것은 크게 어렵지 않았다. 하지만 요즘의 자바스크립트 프레임워크들과 CSR들 때문에, 클라이언트 사이드가 자바스크립트를 실행해서 페이지를 렌더 할 때만 화면에 표시하기 때문에 실질적으로는 웹페이지가 비어있는 것이나 마찬가지이다.

이러한 조건들 때문에 검색 엔진들이 웹페이지들의 인덱싱 작업을 하기 힘들어졌다. 구글을 제외한 다른 검색 엔진들은 구글만큼 자바스크립트 렌더링 역량을 가지고있지 않다. 이 뜻은 당신의 CSR 콘텐츠들은 구글에는 검색될 수 있지만, 다른 검색 엔진들에는 검색이 되지않을 수 있다.

#### SSR과 CSR의 SEO 의미는 무엇일까? 

SSR에서는 HTML 콘텐츠들이 소스코드에 이미 보여지기 때문에 검색 엔진에서 바로 요청을 하고 크롤링을 한 뒤 인덱싱 하는 것이 가능하다. 그렇기 때문에 검색 결과에 빠르게 나타나게 하고 검색 순위를 정하는 것이 가능하다. 

CSR에서는 HTML 콘텐츠들이 자바스크립트에서 완벽히 렌더를 했을 때만 검색이 되어진다. 그렇기 때문에 구글이 사용하는 two wave 시스템을 사용해도 짧게는 몇 시간, 길게는 몇 주가 걸려서 크롤링이 가능하고 인덱싱과 검색 순위가 정해진다. 

#### 이에 대한 해결책은?

이 문제에 대해서는 두 가지의 주요 해결책들이 있다.

1. Pre-rendering: 검색 엔진 봇이 페이지 요청을 할 때, 기본적으로 순수한 HTML 스냅샷을 전송하는 것이다. 이것은 사용자들이 CSR이 제공하는 빠른 웹사이트를 사용할 수 있음과 동시에 검색 엔진에 HTML 콘텐츠를 전송하여 인덱싱과 검색 순위에 오르도록 할 수 있다. 

2. Isomorphic JavaScript(같은 모양의 자바스크립트): 구글에 의해 추천된 방법으로 클라이언트 쪽과 검색 엔진 쪽이 인덱싱이 가능한 HTML 콘텐츠를 처음 페이지가 로드될 때 보내주는 것이다(기본적으로 SSR처럼 작동한다). 모든 자바스크립트 기능들은 맨 위에 위치하여 빠른 클라이언트 쪽 퍼포먼스를 제공한다. 이것은 사용자와 검색엔진에게 가장 좋은 방법이만, 몇 가지의 이슈들이 존재한다. 
  - 실행이 까다로울 수 있으며 많은 개발자들이 이와 관련된 실행법에 대해 쉽지 않아 한다. 성공적으로 이를 구현하기 위한 자원들을 생각해보면, 이는 많은 것을 요구하게 된다. 최고의 방법으로 SSR을 자바스크립트 프레임워크와 작동시키려면 매우 자세한 사전조사가 이루어져야 할 것이다. 
  - [리액트를 통한 isomorphic JavaScript의 구현 방법 예](https://reactjs.org/docs/react-dom-server.html)

#### 참고 자료 

자바스크립트 SEO 조건을 더욱 잘 충족시키기 위해선?

  [JavaScript SEO experts at Elephate](https://www.elephate.com/blog/ultimate-guide-javascript-seo/)


---

### MPA vs SPA

#### MPA

여러 페이지로 어플리케이션이 구성되어 있어서 유저가 요청할 때마다 페이지가 새로고침되고, 페이지를 로딩할 때마다 서버로부터 리소스(이미지, CSS 또는 자바스크립트)를 전달받아 해석 후 렌더링을 한다. 캐싱들도 어느 정도 도움이 되긴 한다. 

- 웹에서 제공되는 정보가 정말 많기 때문에 속도적인 측면에서 문제가 있다. 캐싱과 압축을 하여 서비스를 제공한다해도 사용자와 인터랙션이 많은 요즘 웹 어플리케이션에선 충분하지 않을 수 있다. 


#### SPA

말 그대로, 페이지가 1개인 어플리케이션이란 뜻이다. SPA는 페이지 간 이동이 발생해도 새로고침이 발생하거나 하지 않는다. SPA는 오직 페이지의 일부분만 다시 렌더한다. 이 한 페이지는 수많은 CSS와 이미지들, 그리고 자바스크립트 코드들을 포함한다. 이 자바스크립트 코드들이 URL 변경이라던지 클릭 이벤트들, 그리고 페이지의 일부분을 새로운 데이터로 다시 렌더시킨다. 앵귤러, 뷰 그리고 리액트가 예가 될 수 있다. 

#### 두 방법의 비교
[출처](https://medium.com/@jainshilpa1993/ultimate-death-match-spa-vs-mpa-82e0b79ae6b6)

A) 속도
- SPA는 매우 빠른 속도를 자랑하는데, 이는 SPA의 reactive behavior에서 기반된다. 
- MPA는 느리다. 매번 서버에 새로운 fetch 요청을 보내야만 하기 때문이다. 

B) 커플링(Coupling)
- SPA는 백엔드와 프론트엔드의 코드가 잘 구분되어 있기 때문에 decoupled되어 있다고 보면 된다.
- MPA는 프론트엔드와 백엔드가 매우 coupled되어 있다.

C) SEO
- SPA에서 SEO를 만족시키는 것은 매우 힘들 수 있다. 이것을 도와주는 도구들이 있지만 쉽지 않다.
- MPA에서 SEO를 만족시키는 것은 매우 쉽게 이루어질 수 있다.

D) 자바스크립트에 대한 의존성 
- SPA는 자바스크립트를 기반으로 돌아간다. 브라우저에서 자바스크립트를 사용하지 못하면, SPA는 무용지물이 될 수 있다.
- MPA는 자바스크립트에 전혀 의존하지 않고 만들어질 수도 있다. 상상하긴 힘들지만 불가능하진 않다. 

E) 브라우저 
- SPA는 최신 브라우저들에서 보여지는 것이 최상의 조건이다. 
- MPA는 좀 더 오래된 브라우저들을 지원하기가 편할 것이다.

F) 간편화된 모바일 개발
- SPA는 웹 app이던 mobile app이던 같은 백엔드를 사용할 수 있기 때문에 모바일 개발과 관련하여 좀 더 간편화 되어있다. 
- MPA는 모바일 app을 위한 분리된 코드 기반이 필요하다.

그렇기 때문에 프로젝트를 진행할 때 SPA로 진행할지, MPA로 진행할지는 궁극적으로 원하는 것이 무엇인지를 잘 따져보고 진행해야 한다. 
---
리액트 내에서의 정보들은 어떻게 전달되는 지에 대한 정확한 흐름의 파악 

리덕스 사용의 장점은?

리액트는 사용할 정보들을 미리 받아와서 보여주는 것인가? 아니면 다른 경우?


IE를 맞추는 상황에서 hack은 가장 마지막에 써야할 문제. 그 전에는 최대한 개발자 도구를 열어봐서 해결해봐라.

## 브라우저가 웹 페이지를 렌더하는 과정

  1. HTML에서 DOM(Document Object Model) 구성된다.
  
  2. 스타일이 불러와지고 해석되면서 CSSOM(CSS Object Model)을 구성한다.

  3. DOM과 CSSOM 위에 객체의 묶음이 렌더되도록 하는 렌더링 트리(rendering tree)가 생성이 된다(웹킷에서는 이것들을 'renderer' 또는 'render object'라고 부르고, Gecko에서는 'frame'이라고 부른다). 렌더 트리는 보이지 않는 요소들(header 태그 또는 display: none 설정이 된)을 제외한 DOM 구조를 반영한다. 각각의 텍스트 문자열들이 렌더링 트리에 분리된 renderer로써 나타내진다. 각각의 rendering object들은 그에 상응하는 DOM 객체(또는 a text block)과 계산된 스타일들을 가지고 있다. 다른 말로 하자면, 렌더 트리는 DOM의 시각적 표현을 묘사한다.

  4. 각각의 렌더 트리 요소를 위해 그것의 좌표들이 계산이 되는데, 이것을 레이아웃(layout)이라고 부른다. 브라우저들은 모든 요소들을 배치시키기 위해 하나의 pass를 필요로 하는(테블릿의 경우에는 하나보다 많은 pass가 필요) flow method를 사용한다.

  5. 마지막으로 위의 과정을 거친 렌더 트리가 브라우저 창에 표시가 되는데, 이 과정을 페인팅(painting)이라고 부른다.

---

**버전관리 관련**
버전관리는 어떻게 했는지?

---

**그 외**
회사 제품의 사용이나 웹 사이트의 방문 

개발자를 하게 된 계기 

협업하면서 느낀 점 or 힘들었던 점 or 배운 것

기능 구현하면서 가장 힘들었던 점과 어떻게 구현했는지?







```